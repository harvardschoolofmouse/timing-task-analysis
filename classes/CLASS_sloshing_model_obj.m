classdef CLASS_sloshing_model_obj < handle
	% 
	% 	Created 	11/21/21	ahamilos
	% 	Modified 	ahamilos    4/9/2025       versionCode = 'v2.0.1'
	% 
    % 
	% 
	properties
		iv
		LOTA
		LTA
        CTA
        LONTA
        analysis
    end
	methods
		%-------------------------------------------------------
		%		Methods: Initialization
		%-------------------------------------------------------
		function obj = CLASS_sloshing_model_obj(sObj, c_obj, singleSeshPoolMode, CTAMode, includeRxnsAsEarly, verbose)
            % 
            %   sObj is a single session or composite sObj from v3x photometry objs
            %   c_obj is a STAT_collate object generated by collateKey 'grabMoveControls'
            %   singleSeshPoolMode will allow us to pool *single session data* (rather than get single trials) before running models..
            % 
            if nargin < 6, verbose=true;end
            if nargin < 5, includeRxnsAsEarly = false;end
            if nargin < 4 || isempty(CTAMode), CTAMode = false;end
            if nargin < 3 || isempty(singleSeshPoolMode), singleSeshPoolMode = false;end
            if nargin < 2 || isempty(c_obj), c_obj = [];end
            obj.iv.verbose = verbose;
            if isempty(sObj) % this is a STAT_collate obj
                if ~strcmp(c_obj.iv.collateKey, 'grabMoveControls'), error('STATcollate obj needs to be grabMoveControls as collateKey'), end
                compositeMode = true;
                collatedMode = true;
                % build a dummy sObj
                sObj = c_obj.analysis.gfit;
                sObj.Mode = c_obj.iv.n{2};
                sObj.iv.hasPhot = sum([c_obj.collatedResults.hasPhot])>0;
                sObj.iv.hasEMG = sum([c_obj.collatedResults.hasEMG])>0;
                if sObj.iv.hasEMG, sObj.GLM.EMG = c_obj.analysis.EMG;end
                sObj.iv.hastdt = sum([c_obj.collatedResults.hastdt])>0;
                if sObj.iv.hastdt, sObj.GLM.tdt = c_obj.analysis.tdt;end
                sObj.iv.hasX = sum([c_obj.collatedResults.hasX])>0;
                if sObj.iv.hasX, sObj.GLM.X = c_obj.analysis.X;end
            elseif isfield(sObj.iv, 'versionCode') && contains(sObj.iv.versionCode, 'human')
                collatedMode = false;
                obj.iv.humanMode = true;
                compositeMode = false; 
            else
                if isfield(sObj.iv, 'collateKey'), error('You meant to leave sObj input empty. This is a STAT_collate obj. Use: obj=CLASS_sloshing_model_obj([], c_obj)'), end
                collatedMode = false;
                if strcmp(sObj.iv.setStyle,'v3x Combined Datasets'), compositeMode = true; else,compositeMode = false; end
            end

            if ~isfield(obj.iv, 'humanMode'), obj.iv.humanMode = false;end
			% 
			% 	Takes a statObj as input (photometry) and extracts relevant info. 
            %   Then, prepares for LOTA and LTA analysis
            %
            %   By definition, TRIAL N = the previous trial (whose RPE we are calculating)
            %                   TRIAL N+1 = the next trial (whose lick time we predict)
            % 
            % warning('2/25/23: would be good to rewrite all glmfits as fitglm to use matlab''s verified regression stats, as my rsq was faulty with missing data (fixed but could be other unknown issues...')
            obj.iv.runID = randi(10000);
			obj.iv.versionCode = ['CLASS_sloshing_model_obj v2.0 Modified 6-13-23 | obj created: ' datestr(now)];

            obj.iv.compositeMode = compositeMode; obj.iv.collatedMode = collatedMode;
            obj.iv.includeRxnsAsEarly = includeRxnsAsEarly;
            obj.iv.LTAorLOTA = '';
            if (compositeMode && strcmpi(sObj.Mode, 'times')) || obj.iv.humanMode
                obj.iv.LTAorLOTA = 'LTA';
            elseif compositeMode && strcmpi(sObj.Mode, 'times-lampOff')
                obj.iv.LTAorLOTA = 'LOTA';
            elseif compositeMode
                error('this sObj is in neither times nor LOTA format. can''t use. Check obj.Mode... we only get this data with objs created after 5-10-23')
            end
			
            if obj.iv.humanMode
                obj.iv.mousename_ = sObj.iv.run_id;
                obj.iv.signalname = sObj.iv.ExpCode;
                obj.iv.daynum_ = sObj.iv.code_version;
                obj.iv.code_version = sObj.iv.code_version;
                num_trials = sObj.iv.ntrials_expert + sObj.iv.ntrials_intermediate + sObj.iv.ntrials_beginner;
                obj.iv.num_trials = num_trials;

            elseif ~compositeMode
                obj.iv.mousename_ = sObj.iv.mousename_;
                obj.iv.signalname = sObj.iv.signalname;
                obj.iv.daynum_ = sObj.iv.daynum_;
                obj.iv.num_trials = sObj.iv.num_trials;

                % if stimulated, let's check that
                if numel(sObj.GLM.stimTrials) > 0
                    obj.iv.noStimTrials = sObj.GLM.noStimTrials';
                    obj.iv.stimTrials = sObj.GLM.stimTrials';
                end

            elseif collatedMode
                c_obj.getMouseNames;
                obj.iv.mousename_ = [c_obj.iv.nmice 'mice'];
                obj.iv.signalname = strjoin([c_obj.iv.signal],"/");
                obj.iv.daynum_ = [c_obj.iv.nsesh 'sesh'];
            else
                obj.iv.mousename_ = [num2str(numel(unique([sObj.iv.datasetMap.mouseName]))) 'mouse'];
                obj.iv.signalname = sObj.iv.signalname;
                obj.iv.daynum_ = [num2str(numel([sObj.iv.datasetMap.mouseName])) 'sesh'];
            end
            obj.iv.sessionCode = [obj.iv.mousename_ '_' obj.iv.signalname '_' obj.iv.daynum_];
            
            obj.iv.smoothing = 70; % this is our default
            % prep LTA analysis:
            if ~compositeMode || strcmp(obj.iv.LTAorLOTA,'LTA')
                obj.init_LTA(sObj, singleSeshPoolMode);
            end
            % prep LOTA analysis:
            if ~obj.iv.humanMode
                if ~compositeMode  || strcmp(obj.iv.LTAorLOTA,'LOTA')
                    obj.init_LOTA(sObj, singleSeshPoolMode);
                end
            end
            if CTAMode
                warning('CTAMode hasn''t been fully tested. It was built from LTA mode 7-18-23')
                obj.init_CTA(sObj, singleSeshPoolMode);
            end
            % initialize file...
            obj.iv.savefilename = ['SloshingModel_' obj.iv.sessionCode, '_'  datestr(now, 'YYYYmmDD_HH_MM') '_runIDno' num2str(obj.iv.runID)];
            if verbose, disp('  ******** obj **NOT** saved by default. use obj.save'),end
        end
        function save(obj)
            ID = obj.iv.runID;
            savefilename = cell2mat(['SloshingModel_' obj.iv.sessionCode, '_'  datestr(now, 'YYYYmmDD_HH_MM') '_runIDno' num2str(ID)]);
            save([savefilename, '.mat'], 'obj', '-v7.3');
            disp(['Saved revised object to ' strjoin(strsplit(pwd, '\'), '/') savefilename '.mat (' datestr(now,'HH:MM AM') ')']);
        end
        function Str = getUserDataStandards(obj)
            Str = ['\nrunID:    ' num2str(obj.iv.runID),...
            '\nversionCode:  ' obj.iv.versionCode,...
            '\n\nobj.iv.mousename_: ' obj.iv.mousename_,...
            '\nsignalname:  ' obj.unwrap_Cellstr(obj.iv.signalname),...
            '\ndaynum_: ' obj.unwrap_Cellstr(obj.iv.daynum_),...
            '\n\ncompositeMode:   ' obj.unwrap_Cellstr(obj.iv.compositeMode),...
            '\ncollatedMode:   ' obj.unwrap_Cellstr(obj.iv.collatedMode),...
            '\nincludeRxnsAsEarly:   ' obj.unwrap_Cellstr(obj.iv.includeRxnsAsEarly),...
            '\nnum_trials:   ' obj.unwrap_Cellstr(obj.iv.num_trials),...
            '\nLTAorLOTA:   ' obj.unwrap_Cellstr(obj.iv.LTAorLOTA),...
            '\nsmoothing:  '  obj.unwrap_Cellstr(obj.iv.smoothing),...
            '\nhumanMode:  '  obj.unwrap_Cellstr(obj.iv.humanMode),...
            '\n\nsavefilename:   ' correctPathOS(obj.unwrap_Cellstr(obj.iv.savefilename), 'mac'),...
            '\n\n\n LTA DATA:',...
            '\nLTA RPEwin:  '  obj.unwrap_Cellstr(obj.LTA.RPEwin),...
            '\nLTA RPEwin_xshift:  '  obj.unwrap_Cellstr(obj.LTA.RPEwin_xshift),...
            '\n\n\n LOTA DATA:',...
            '\nLOTA RPEwin:  '  obj.unwrap_Cellstr(obj.LOTA.RPEwin),...
            '\nLOTA RPEwin_xshift:  '  obj.unwrap_Cellstr(obj.LOTA.RPEwin_xshift),...
            ];
        end
        function str = unwrap_Cellstr(obj, C)
			
			if iscell(C)
                str = {};
				for iC = 1:numel(C)
					if isnumeric(C{iC}) || islogical(C{iC})
						if numel(C{iC} > 1)
							str{end+1} = num2str(C{iC});
							str{end} = ['[', str{end}, ']'];
						else
							str{end+1} = num2str(C{iC});
						end
					elseif iscell(C{iC})
						str{end+1} = obj.unwrap_Cellstr(C{iC});
					else
						str{end+1} = C{iC};
					end
					if iC ~= numel(C)
						str{end+1} = ', ';
					end
	            end
	            str = cell2mat(str);
            elseif isnumeric(C) || islogical(C)
            	str = mat2str(C);
        	elseif isstruct(C)
        		fn = fieldnames(C);
        		str = {};
        		for ifield = 1:numel(fn)
        			str{ifield} = [correctPathOS([fn{ifield},': ' eval(['obj.unwrap_Cellstr(C.', fn{ifield} ');'])], 'mac'), '\n'];
    			end
    			str = cell2mat(str);
        	else
        		str = correctPathOS(C, 'mac');
    		end
            
            if iscell(C)
	            str = ['{' str '}'];
            elseif isnumeric(C) || islogical(C)
            	str = ['[' str ']'];
            end
            str = sprintf(str);
		end
        function init_LTA(obj, sObj, BinningMode)
            % 
            %   Binning Mode will allow us to either do single trial analyses or averages
            %           BinningMode = {'singletrial',17};
            %           BinningMode = {'times',17};
            % 
            %       Default is the single trial analysis. But to do averages, we will bin the data, and then we will predict averages of stuff
            % 
            if nargin < 3 || islogical(BinningMode) && ~BinningMode
                BinningMode = {'singletrial',17};
            elseif islogical(BinningMode) && BinningMode
                % we will pool trials on the single session obj
                BinningMode = {'times', 68};%{'custom', [0:250:3329, 3334:250:6999,7000:250:17000]};
            else
                error('BinningMode needs to be logical')
            end
            smoothing = obj.iv.smoothing;
            RPEwin_xshift = 0; %time after lick
            RPEwin = 5000;%5000;
            if ~isfield(obj.iv, 'compositeMode'), obj.iv.compositeMode = false; end
            if ~obj.iv.compositeMode && ~obj.iv.humanMode
                % 
                %  only want to bin up if this is not a composite sObj, which already comes binned
                % 
                sObj.getBinnedTimeseries(sObj.GLM.gfit, BinningMode{1}, BinningMode{2}, 20000, [], [], false, [], 'off');
            end
           
            %
            if obj.iv.humanMode
                xzero = 1;
                window_start_pos = xzero + RPEwin_xshift;
                % keeping nans in situ for now
                lick_time = [sObj.Events.beginner.flick_s_wrtc;sObj.Events.intermediate.flick_s_wrtc;sObj.Events.expert.flick_s_wrtc];
                trials_in_each_bin = num2cell(1:numel(lick_time));
            else
                xzero = find(sObj.ts.Plot.LTA.xticks.s==0);
                window_start_pos = xzero + RPEwin_xshift;
                trials_in_each_bin = sObj.ts.BinParams.trials_in_each_bin;
                if strcmpi(BinningMode{1}, 'singletrial')
                    lick_time = [sObj.ts.BinParams.s.CLTA_Max]';
                elseif ~obj.iv.compositeMode
                    % take the average lick time in the bin
    %                 lick_time = cell2mat(cellfun(@(x) mean(sObj.GLM.flick_s_wrtc(x)), sObj.ts.BinParams.trials_in_each_bin, 'uniformoutput', false));
                    next_trial = cellfun(@(x)x+1,sObj.ts.BinParams.trials_in_each_bin, 'uniformoutput',0);
                    next_trial_is_ok = cellfun(@(x) ~isnan(sObj.GLM.flick_s_wrtc(x)), next_trial, 'uniformoutput',0);
                    next_trial_is_ok = cellfun(@(x) zero2nan(double(x)), next_trial_is_ok, 'uniformoutput',0);
                    % if the next trial is nan, we gotta exclude the previous
                    % trial...
                    lick_times = cellfun(@(x) sObj.GLM.flick_s_wrtc(x), sObj.ts.BinParams.trials_in_each_bin, 'uniformoutput', false);
                    lick_times = cellfun(@(x,y) x.*y, lick_times, next_trial_is_ok, 'uniformoutput', false);
                    lick_time = cell2mat(cellfun(@(x) nanmean(x), lick_times, 'uniformoutput', false));
                else 
                    % we already saved this in our composite ts field
                    lick_time = cell2mat(cellfun(@(x) nanmean(x),sObj.ts.BinParams.lick_times_in_each_bin, 'uniformoutput', 0));
                end
            end
            rews = find(lick_time >= 3.333 & lick_time < 7);
            if obj.iv.includeRxnsAsEarly 
                early = find(lick_time < 3.33);
            else
                early = find(lick_time >= 0.7 & lick_time < 3.33);
            end
            rxn = find(lick_time < 0.7);                
            iti = find(lick_time >= 7);
            % smooth the LTAs
            if obj.iv.humanMode
                smoothedLTA = cellfun(@(x) nan(window_start_pos+RPEwin,1),num2cell(1:numel(lick_time)),'uniformoutput',0);
                mins = nan(size(lick_time));
                maxs = nan(size(lick_time));
                means = nan(size(lick_time));
                medians = nan(size(lick_time));
                next_trial = 2:numel(lick_time)+1;
                lick_time_next_trial = [lick_time(2:end);nan];
                log_lick_time_next_trial = log(lick_time_next_trial);
                delta_lick_time = lick_time_next_trial - lick_time;
                shuffled_lick_time_next_trial = lick_time_next_trial(randperm(numel(lick_time_next_trial)));
                shuffled_lick_time_next_trial(next_trial == obj.iv.num_trials+1) = nan;
                % shuffled_lick_time_next_trial = sObj.GLM.flick_s_wrtc(randperm(numel(sObj.GLM.flick_s_wrtc)));
                shuffled_delta_lick_time = shuffled_lick_time_next_trial - lick_time;
            else
                smoothedLTA = cellfun(@(x) v3x_smooth(x,smoothing), sObj.ts.BinnedData.LTA, 'uniformoutput', 0)';
                % prep Rails signals
                mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), smoothedLTA, 'uniformoutput', 0));
                maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), smoothedLTA, 'uniformoutput', 0));
                % prep mean/median signals
                means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), smoothedLTA, 'uniformoutput', 0));
                medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), smoothedLTA, 'uniformoutput', 0));
                % map this back to the trial order so we can predict behavior on next trial
                if ~obj.iv.compositeMode && strcmpi(BinningMode{1}, 'singletrial')
                    if isfield(obj.iv, 'stimTrials')
                        % specify indicies of stim trials
                        obj.LTA.stimIdx = find(ismember(cell2mat(sObj.ts.BinParams.trials_in_each_bin), obj.iv.stimTrials));
                        obj.LTA.nostimIdx = find(ismember(cell2mat(sObj.ts.BinParams.trials_in_each_bin), obj.iv.noStimTrials));
                    end
                    next_trial = cell2mat(sObj.ts.BinParams.trials_in_each_bin)+1;
                    lick_time_next_trial = sObj.GLM.flick_s_wrtc(next_trial);
                    lick_time_next_trial(next_trial == sObj.iv.num_trials+1) = nan;
                    log_lick_time_next_trial = log(lick_time_next_trial);
                    delta_lick_time = lick_time_next_trial - lick_time;
                    shuffled_lick_time_next_trial = lick_time_next_trial(randperm(numel(lick_time_next_trial)));
                    shuffled_lick_time_next_trial(next_trial == sObj.iv.num_trials+1) = nan;
                    % shuffled_lick_time_next_trial = sObj.GLM.flick_s_wrtc(randperm(numel(sObj.GLM.flick_s_wrtc)));
                    shuffled_delta_lick_time = shuffled_lick_time_next_trial - lick_time;

                elseif ~obj.iv.compositeMode                
                    lick_time_next_trial = cell2mat(cellfun(@(x) nanmean(sObj.GLM.flick_s_wrtc(x)),next_trial,'uniformoutput',0));
    %                 lick_time_next_trial(next_trial == sObj.iv.num_trials+1) = nan;
                    log_lick_time_next_trial = log(lick_time_next_trial);
                    delta_lick_time = lick_time_next_trial - lick_time;

                    shuffled_lick_time_next_trial = lick_time_next_trial(randperm(numel(lick_time_next_trial)));
                    shuffled_lick_time_next_trial(next_trial == sObj.iv.num_trials+1) = nan;
                    shuffled_delta_lick_time = shuffled_lick_time_next_trial - lick_time;
                else
                    next_trial = cell2mat(sObj.ts.BinParams.trials_in_each_bin)+1; % doesnt make sense for this obj!

                    lick_time_next_trial = cell2mat(cellfun(@(x) nanmean(x), sObj.ts.BinParams.lick_times_next_trial, 'uniformoutput',0));
                    log_lick_time_next_trial = log(lick_time_next_trial);
                    delta_lick_time = cell2mat(cellfun(@(x) nanmean(x), sObj.ts.BinParams.lick_time_tp1_minus_tn, 'uniformoutput',0));     
                    shuffled_lick_time_next_trial = []; % not sure how to implement
                    shuffled_delta_lick_time = [];           
                end
            end
            % assign RPE to each trial: (note this means RAILS signal)
            RPE = nan(numel(lick_time_next_trial),1);
            RPE(rews) = maxs(rews);
            RPE(early) = mins(early);
            
            if ~obj.iv.humanMode
                if isfield(sObj.GLM,'EMG')
                    if ~obj.iv.collatedMode
                        sObj.getBinnedTimeseries(abs(sObj.GLM.EMG(1:2:end)), BinningMode{1}, BinningMode{2}, 20000, [], [], false, [], 'off');
                        EMGts = sObj.ts.BinnedData.LTA;
                    else
                        EMGts = sObj.GLM.EMG.ts.BinnedData.LTA;
                    end
                    % downsample
                    EMG_LTA = cellfun(@(x) v3x_smooth(x,smoothing), EMGts, 'uniformoutput', 0)';
                    obj.LTA.EMG.EMG_LTA = EMG_LTA;
                    % prep Rails signals
                    obj.LTA.EMG.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), EMG_LTA, 'uniformoutput', 0));
                    obj.LTA.EMG.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), EMG_LTA, 'uniformoutput', 0));
                    % prep mean/median signals
                    obj.LTA.EMG.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), EMG_LTA, 'uniformoutput', 0));
                    obj.LTA.EMG.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), EMG_LTA, 'uniformoutput', 0));
                    % assign RPE to each trial: (note this means RAILS signal)
                    obj.LTA.EMG.RPE = nan(numel(lick_time_next_trial),1);
                    obj.LTA.EMG.RPE(rews) = obj.LTA.EMG.maxs(rews);
                    obj.LTA.EMG.RPE(early) = obj.LTA.EMG.mins(early);
                end
                if isfield(sObj.GLM,'gX')
                    if ~obj.iv.collatedMode
                        sObj.getBinnedTimeseries(abs(sObj.GLM.gX(1:2:end)), BinningMode{1}, BinningMode{2}, 20000, [], [], false, [], 'off');
                        Xts = sObj.ts.BinnedData.LTA;
                    else
                        Xts = sObj.GLM.X.ts.BinnedData.LTA;
                    end
                    % downsample
                    X_LTA = cellfun(@(x) v3x_smooth(x,smoothing), Xts, 'uniformoutput', 0)';
                    obj.LTA.X.X_LTA = X_LTA;
                    % prep Rails signals
                    obj.LTA.X.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), X_LTA, 'uniformoutput', 0));
                    obj.LTA.X.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), X_LTA, 'uniformoutput', 0));
                    % prep mean/median signals
                    obj.LTA.X.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), X_LTA, 'uniformoutput', 0));
                    obj.LTA.X.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), X_LTA, 'uniformoutput', 0));
                    % assign RPE to each trial: (note this means RAILS signal)
                    obj.LTA.X.RPE = nan(numel(lick_time_next_trial),1);
                    obj.LTA.X.RPE(rews) = obj.LTA.X.maxs(rews);
                    obj.LTA.X.RPE(early) = obj.LTA.X.mins(early);
                end
                if isfield(sObj.GLM,'tdt')
                    if ~obj.iv.collatedMode
                        sObj.getBinnedTimeseries(sObj.GLM.tdt, BinningMode{1}, BinningMode{2}, 20000, [], [], false, [], 'off');
                        tdtts = sObj.ts.BinnedData.LTA;
                    else
                        tdtts = sObj.GLM.tdt.ts.BinnedData.LTA;
                    end
                    % downsample
                    tdt_LTA = cellfun(@(x) v3x_smooth(x,smoothing), tdtts, 'uniformoutput', 0)';
                    obj.LTA.tdt.tdt_LTA = tdt_LTA;
                    % prep Rails signals
                    obj.LTA.tdt.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), tdt_LTA, 'uniformoutput', 0));
                    obj.LTA.tdt.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), tdt_LTA, 'uniformoutput', 0));
                    % prep mean/median signals
                    obj.LTA.tdt.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), tdt_LTA, 'uniformoutput', 0));
                    obj.LTA.tdt.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), tdt_LTA, 'uniformoutput', 0));
                    % assign RPE to each trial: (note this means RAILS signal)
                    obj.LTA.tdt.RPE = nan(numel(lick_time_next_trial),1);
                    obj.LTA.tdt.RPE(rews) = obj.LTA.tdt.maxs(rews);
                    obj.LTA.tdt.RPE(early) = obj.LTA.tdt.mins(early);
                end
            end

            obj.LTA.RPEwin_xshift = RPEwin_xshift;
            obj.LTA.RPEwin = RPEwin;
            obj.LTA.window_start_pos = window_start_pos;
            obj.LTA.lick_time = lick_time;
            obj.LTA.lick_time_next_trial = lick_time_next_trial;
            obj.LTA.shuffled_lick_time_next_trial = shuffled_lick_time_next_trial;
            obj.LTA.shuffled_delta_lick_time = shuffled_delta_lick_time;
            obj.LTA.rxn = rxn;
            obj.LTA.early = early;
            obj.LTA.rews = rews;
            obj.LTA.iti = iti;
            obj.LTA.smoothedLTA = smoothedLTA;
            obj.LTA.mins = mins;
            obj.LTA.maxs = maxs;
            obj.LTA.RPE = RPE;
            obj.LTA.means = means;
            obj.LTA.medians = medians;
            obj.LTA.trials_in_each_bin = trials_in_each_bin;
            obj.LTA.next_trial = next_trial;
            obj.LTA.log_lick_time_next_trial = log_lick_time_next_trial;
            obj.LTA.delta_lick_time = delta_lick_time;
            if ~obj.iv.humanMode
                obj.LTA.xticks_s = sObj.ts.Plot.LTA.xticks.s;
            end
            obj.LTA.xzero = xzero;
            obj.LTA.Models(1).Model = '';
            obj.LTA.Models(1).Signal = '';
            obj.LTA.Models(1).Window = [];
            obj.LTA.Models(1).B = [];
            obj.LTA.Models(1).DEV = [];
            obj.LTA.Models(1).STATS = [];
            obj.LTA.Models(1).yfit = [];
            obj.LTA.Models(1).rsq = [];
            obj.LTA.Models(1).resid = [];
            obj.LTA.BinningMode = BinningMode;
        end
        function resetLTA(obj, RPEwin_xshift,RPEwin)
            obj.LTA.RPEwin_xshift = RPEwin_xshift; %time post-lick
            obj.LTA.RPEwin = RPEwin;%5000;
            % warning('why was this LOTA.xzero?????') resolved! did not
            % affect results, pos 0 is always same for CTA and LTA...
            window_start_pos = obj.LTA.xzero + RPEwin_xshift;%obj.LOTA.xzero + RPEwin_xshift;
            obj.LTA.window_start_pos = window_start_pos;
            smoothedLTA = obj.LTA.smoothedLTA;
            lick_time_next_trial = obj.LTA.lick_time_next_trial;
            rews = obj.LTA.rews;
            early = obj.LTA.early;
            % prep Rails signals
            obj.LTA.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), smoothedLTA, 'uniformoutput', 0));
            obj.LTA.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), smoothedLTA, 'uniformoutput', 0));
            % prep mean/median signals
            obj.LTA.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), smoothedLTA, 'uniformoutput', 0));
            obj.LTA.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), smoothedLTA, 'uniformoutput', 0));
            % assign RPE to each trial: (note this means RAILS signal)
            obj.LTA.RPE = nan(numel(lick_time_next_trial),1);
            obj.LTA.RPE(rews) = obj.LTA.maxs(rews);
            obj.LTA.RPE(early) = obj.LTA.mins(early);
            if isfield(obj.LTA,'EMG')
                EMG_LTA = obj.LTA.EMG.EMG_LTA;
                % prep Rails signals
                obj.LTA.EMG.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), EMG_LTA, 'uniformoutput', 0));
                obj.LTA.EMG.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), EMG_LTA, 'uniformoutput', 0));
                % prep mean/median signals
                obj.LTA.EMG.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), EMG_LTA, 'uniformoutput', 0));
                obj.LTA.EMG.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), EMG_LTA, 'uniformoutput', 0));
                % assign RPE to each trial: (note this means RAILS signal)
                obj.LTA.EMG.RPE = nan(numel(lick_time_next_trial),1);
                obj.LTA.EMG.RPE(rews) = obj.LTA.EMG.maxs(rews);
                obj.LTA.EMG.RPE(early) = obj.LTA.EMG.mins(early);
            end
            if isfield(obj.LTA,'X')
                X_LTA = obj.LTA.X.X_LTA;
                % prep Rails signals
                obj.LTA.X.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), X_LTA, 'uniformoutput', 0));
                obj.LTA.X.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), X_LTA, 'uniformoutput', 0));
                % prep mean/median signals
                obj.LTA.X.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), X_LTA, 'uniformoutput', 0));
                obj.LTA.X.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), X_LTA, 'uniformoutput', 0));
                % assign RPE to each trial: (note this means RAILS signal)
                obj.LTA.X.RPE = nan(numel(lick_time_next_trial),1);
                obj.LTA.X.RPE(rews) = obj.LTA.X.maxs(rews);
                obj.LTA.X.RPE(early) = obj.LTA.X.mins(early);
            end
            if isfield(obj.LTA,'tdt')
                tdt_LTA = obj.LTA.tdt.tdt_LTA;
                % prep Rails signals
                obj.LTA.tdt.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), tdt_LTA, 'uniformoutput', 0));
                obj.LTA.tdt.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), tdt_LTA, 'uniformoutput', 0));
                % prep mean/median signals
                obj.LTA.tdt.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), tdt_LTA, 'uniformoutput', 0));
                obj.LTA.tdt.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), tdt_LTA, 'uniformoutput', 0));
                % assign RPE to each trial: (note this means RAILS signal)
                obj.LTA.tdt.RPE = nan(numel(lick_time_next_trial),1);
                obj.LTA.tdt.RPE(rews) = obj.LTA.tdt.maxs(rews);
                obj.LTA.tdt.RPE(early) = obj.LTA.tdt.mins(early);
            end
        end
        function init_LOTA(obj, sObj, BinningMode)
            if nargin < 3 || islogical(BinningMode) && ~BinningMode
                BinningMode = {'SingleTrialwrtLO',17};
            elseif islogical(BinningMode) && BinningMode
                % we will pool trials on the single session obj
                BinningMode = {'times-lampoff',68}; %custom-lampoff', [0:250:3329, 3334:250:6999,7000:250:17000]};
            end
                
            smoothing = obj.iv.smoothing;
            RPEwin_xshift = -10000; %time before Lamp-Off
            RPEwin = 1500;%5000;
            if ~isfield(obj.iv, 'compositeMode'), obj.iv.compositeMode = false; end
            if ~isfield(obj.iv, 'collatedMode'), obj.iv.collatedMode = false; end
            if ~obj.iv.compositeMode
                % 
                %  only want to bin up if this is not a composite sObj, which already comes binned
                % 
                sObj.getBinnedTimeseries(sObj.GLM.gfit, BinningMode{1}, BinningMode{2}, 20000, [], [], false, [], 'off');
            end
            xzero = find(sObj.ts.Plot.CTA.xticks.s==0);
            window_start_pos = xzero + RPEwin_xshift;
            trials_in_each_bin = sObj.ts.BinParams.trials_in_each_bin;
            if ~obj.iv.compositeMode && numel([sObj.ts.BinParams.s.CLTA_Max]) == numel(sObj.GLM.flick_s_wrtc(~isnan(sObj.GLM.flick_s_wrtc))) || obj.iv.Early_or_Rew_conditionedMode
                % this is for our NOT custom binned mode
                %
                % remember, our data here needs to be re-aligned to PREVIOUS
                % trial since we are looking at ITI...
                prev_trial = cell2mat(sObj.ts.BinParams.trials_in_each_bin) - 1;
                exxx = find(prev_trial<1);
                prev_trial(prev_trial<1) = 1;
                lick_time = sObj.GLM.flick_s_wrtc(prev_trial);
                prev_trial(exxx) = nan;
                lick_time(exxx) = nan;
                lick_time_next_trial = [sObj.ts.BinParams.s.CLTA_Max]';
                rews = find(lick_time >= 3.333 & lick_time < 7);
                if obj.iv.includeRxnsAsEarly 
                    early = find(lick_time < 3.33);
                else
                    early = find(lick_time >= 0.7 & lick_time < 3.33);
                end
                % early = find(lick_time >= 0.7 & lick_time < 3.33);
                rxn = find(lick_time < 0.7);
                iti = find(lick_time >= 7);
                
                % map this back to the trial order so we can predict behavior on next trial
                next_trial = cell2mat(sObj.ts.BinParams.trials_in_each_bin); % note here is current trial!
                log_lick_time_next_trial = log(lick_time_next_trial);
                delta_lick_time = lick_time_next_trial - lick_time;

                shuffled_lick_time_next_trial = lick_time_next_trial(randperm(numel(lick_time_next_trial)));
                shuffled_lick_time_next_trial(next_trial == sObj.iv.num_trials+1) = nan;
                shuffled_delta_lick_time = shuffled_lick_time_next_trial - lick_time;
            elseif ~obj.iv.compositeMode % BinningMode is custom
                lick_time = cell2mat(cellfun(@(x) nanmean(x), sObj.ts.BinParams.lick_times_previous_trial, 'uniformoutput', 0));
                lick_time_next_trial = cell2mat(cellfun(@(x) nanmean(x), sObj.ts.BinParams.lick_times_in_each_bin, 'uniformoutput', 0));
                rews = find(lick_time >= 3.333 & lick_time < 7);
                % early = find(lick_time >= 0.7 & lick_time < 3.33);
                if obj.iv.includeRxnsAsEarly 
                    early = find(lick_time < 3.33);
                else
                    early = find(lick_time >= 0.7 & lick_time < 3.33);
                end
                rxn = find(lick_time < 0.7);
                iti = find(lick_time >= 7);

                prev_trial = cell2mat(sObj.ts.BinParams.trials_in_each_bin); % doesnt make sense for this obj!
                next_trial = cell2mat(sObj.ts.BinParams.trials_in_each_bin); % doesnt make sense for this obj!
                log_lick_time_next_trial = log(lick_time_next_trial);
                delta_lick_time = cellfun(@(x) nanmean(x), sObj.ts.BinParams.lick_time_tn_minus_tprev1, 'uniformoutput', 0); 

                shuffled_lick_time_next_trial = []; % not sure how to implement
                shuffled_delta_lick_time = [];
            else
                lick_time = cell2mat(cellfun(@(x) nanmean(x), sObj.ts.BinParams.lick_times_previous_trial, 'uniformoutput', 0));
                lick_time_next_trial = cell2mat(cellfun(@(x) nanmean(x), sObj.ts.BinParams.lick_times_in_each_bin, 'uniformoutput', 0));
                rews = find(lick_time >= 3.333 & lick_time < 7);
                % early = find(lick_time >= 0.7 & lick_time < 3.33);
                if obj.iv.includeRxnsAsEarly 
                    early = find(lick_time < 3.33);
                else
                    early = find(lick_time >= 0.7 & lick_time < 3.33);
                end
                rxn = find(lick_time < 0.7);
                iti = find(lick_time >= 7);

                prev_trial = cell2mat(sObj.ts.BinParams.trials_in_each_bin); % doesnt make sense for this obj!
                next_trial = cell2mat(sObj.ts.BinParams.trials_in_each_bin); % doesnt make sense for this obj!
                log_lick_time_next_trial = log(lick_time_next_trial);
                delta_lick_time = cellfun(@(x) nanmean(x), sObj.ts.BinParams.lick_time_tn_minus_tprev1, 'uniformoutput', 0);

                shuffled_lick_time_next_trial = []; % not sure how to implement
                shuffled_delta_lick_time = [];
            end
            % smooth the LOTAs
            smoothedLOTA = cellfun(@(x) v3x_smooth(x,smoothing), sObj.ts.BinnedData.CTA, 'uniformoutput', 0)';
            % prep Rails signals
            mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), smoothedLOTA, 'uniformoutput', 0));
            maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), smoothedLOTA, 'uniformoutput', 0));
            % prep mean/median signals
            means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), smoothedLOTA, 'uniformoutput', 0));
            medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), smoothedLOTA, 'uniformoutput', 0));
            % assign RPE to each trial: (note this means RAILS signal)
            RPE = nan(numel(lick_time_next_trial),1);
            RPE(rews) = maxs(rews);
            RPE(early) = mins(early);

            if isfield(sObj.GLM,'EMG')
                if ~obj.iv.collatedMode
                    sObj.getBinnedTimeseries(abs(sObj.GLM.EMG(1:2:end)), BinningMode{1}, BinningMode{2}, 20000, [], [], false, [], 'off');
                    EMGts = sObj.ts.BinnedData.CTA;
                else
                    EMGts = sObj.GLM.EMG.ts.BinnedData.CTA;
                end
                % downsample
                EMG_LOTA = cellfun(@(x) v3x_smooth(x,smoothing), EMGts, 'uniformoutput', 0)';
                obj.LOTA.EMG.EMG_LOTA = EMG_LOTA;
                % prep Rails signals
                obj.LOTA.EMG.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), EMG_LOTA, 'uniformoutput', 0));
                obj.LOTA.EMG.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), EMG_LOTA, 'uniformoutput', 0));
                % prep mean/median signals
                obj.LOTA.EMG.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), EMG_LOTA, 'uniformoutput', 0));
                obj.LOTA.EMG.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), EMG_LOTA, 'uniformoutput', 0));
                % assign RPE to each trial: (note this means RAILS signal)
                obj.LOTA.EMG.RPE = nan(numel(lick_time_next_trial),1);
                obj.LOTA.EMG.RPE(rews) = obj.LOTA.EMG.maxs(rews);
                obj.LOTA.EMG.RPE(early) = obj.LOTA.EMG.mins(early);
                obj.LOTA.EMG.Models(1).Model = '';
                obj.LOTA.EMG.Models(1).Signal = '';
                obj.LOTA.EMG.Models(1).Window = [];
                obj.LOTA.EMG.Models(1).B = [];
                obj.LOTA.EMG.Models(1).DEV = [];
                obj.LOTA.EMG.Models(1).STATS = [];
                obj.LOTA.EMG.Models(1).yfit = [];
                obj.LOTA.EMG.Models(1).rsq = [];
                obj.LOTA.EMG.Models(1).resid = [];
            else
                if obj.iv.verbose,warning('no EMG'),end
            end
            if isfield(sObj.GLM,'gX')
                if ~obj.iv.collatedMode
                    sObj.getBinnedTimeseries(abs(sObj.GLM.gX(1:2:end)), BinningMode{1}, BinningMode{2}, 20000, [], [], false, [], 'off');
                    Xts = sObj.ts.BinnedData.CTA;
                else
                    Xts = sObj.GLM.X.ts.BinnedData.CTA;
                end
                % downsample
                X_LOTA = cellfun(@(x) v3x_smooth(x,smoothing), Xts, 'uniformoutput', 0)';
                obj.LOTA.X.EMG_LOTA = X_LOTA;
                % prep Rails signals
                obj.LOTA.X.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), X_LOTA, 'uniformoutput', 0));
                obj.LOTA.X.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), X_LOTA, 'uniformoutput', 0));
                % prep mean/median signals
                obj.LOTA.X.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), X_LOTA, 'uniformoutput', 0));
                obj.LOTA.X.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), X_LOTA, 'uniformoutput', 0));
                % assign RPE to each trial: (note this means RAILS signal)
                obj.LOTA.X.RPE = nan(numel(lick_time_next_trial),1);
                obj.LOTA.X.RPE(rews) = obj.LOTA.X.maxs(rews);
                obj.LOTA.X.RPE(early) = obj.LOTA.X.mins(early);
            else
                if obj.iv.verbose,warning('no gX'),end
            end
            if isfield(sObj.GLM,'tdt')
                if ~obj.iv.collatedMode
                    sObj.getBinnedTimeseries(sObj.GLM.tdt, BinningMode{1}, BinningMode{2}, 20000, [], [], false, [], 'off');
                    tdtts = sObj.ts.BinnedData.CTA;
                else
                    tdtts = sObj.GLM.tdt.ts.BinnedData.CTA;
                end
                % downsample
                tdt_LOTA = cellfun(@(x) v3x_smooth(x,smoothing), tdtts, 'uniformoutput', 0)';
                obj.LOTA.tdt.tdt_LOTA = tdt_LOTA;
                % prep Rails signals
                obj.LOTA.tdt.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), tdt_LOTA, 'uniformoutput', 0));
                obj.LOTA.tdt.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), tdt_LOTA, 'uniformoutput', 0));
                % prep mean/median signals
                obj.LOTA.tdt.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), tdt_LOTA, 'uniformoutput', 0));
                obj.LOTA.tdt.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), tdt_LOTA, 'uniformoutput', 0));
                % assign RPE to each trial: (note this means RAILS signal)
                obj.LOTA.tdt.RPE = nan(numel(lick_time_next_trial),1);
                obj.LOTA.tdt.RPE(rews) = obj.LOTA.tdt.maxs(rews);
                obj.LOTA.tdt.RPE(early) = obj.LOTA.tdt.mins(early);
                obj.LOTA.tdt.Models(1).Model = '';
                obj.LOTA.tdt.Models(1).Signal = '';
                obj.LOTA.tdt.Models(1).Window = [];
                obj.LOTA.tdt.Models(1).B = [];
                obj.LOTA.tdt.Models(1).DEV = [];
                obj.LOTA.tdt.Models(1).STATS = [];
                obj.LOTA.tdt.Models(1).yfit = [];
                obj.LOTA.tdt.Models(1).rsq = [];
                obj.LOTA.tdt.Models(1).resid = [];
            else
                warning('no tdt')
            end

            obj.LOTA.RPEwin_xshift = RPEwin_xshift;
            obj.LOTA.RPEwin = RPEwin;
            obj.LOTA.window_start_pos = window_start_pos;
            obj.LOTA.prev_trial = prev_trial;
            obj.LOTA.lick_time = lick_time;
            obj.LOTA.lick_time_next_trial = lick_time_next_trial;
            obj.LOTA.shuffled_lick_time_next_trial = shuffled_lick_time_next_trial;
            obj.LOTA.rxn = rxn;
            obj.LOTA.early = early;
            obj.LOTA.rews = rews;
            obj.LOTA.iti = iti;
            obj.LOTA.smoothedLOTA = smoothedLOTA;
            obj.LOTA.mins = mins;
            obj.LOTA.maxs = maxs;
            obj.LOTA.RPE = RPE;
            obj.LOTA.means = means;
            obj.LOTA.medians = medians;
            obj.LOTA.trials_in_each_bin = trials_in_each_bin;
            obj.LOTA.next_trial = next_trial;
            obj.LOTA.log_lick_time_next_trial = log_lick_time_next_trial;
            obj.LOTA.delta_lick_time = delta_lick_time;
            obj.LOTA.shuffled_delta_lick_time = shuffled_delta_lick_time;
            obj.LOTA.xticks_s = sObj.ts.Plot.CTA.xticks.s;
            obj.LOTA.xzero = xzero;
            obj.LOTA.Models(1).Model = '';
            obj.LOTA.Models(1).Signal = '';
            obj.LOTA.Models(1).Window = [];
            obj.LOTA.Models(1).B = [];
            obj.LOTA.Models(1).DEV = [];
            obj.LOTA.Models(1).STATS = [];
            obj.LOTA.Models(1).yfit = [];
            obj.LOTA.Models(1).rsq = [];
            obj.LOTA.Models(1).resid = [];
            obj.LOTA.BinningMode = BinningMode;
        end
        function resetLOTA(obj, RPEwin_xshift,RPEwin)
            obj.LOTA.RPEwin_xshift = RPEwin_xshift; %time before Lamp-Off
            obj.LOTA.RPEwin = RPEwin;%5000;
            window_start_pos = obj.LOTA.xzero + RPEwin_xshift;
            lick_time_next_trial = obj.LOTA.lick_time_next_trial;
            obj.LOTA.window_start_pos = window_start_pos;
            smoothedLOTA = obj.LOTA.smoothedLOTA;
            rews = obj.LOTA.rews;
            early = obj.LOTA.early;
            % prep Rails signals
            obj.LOTA.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), smoothedLOTA, 'uniformoutput', 0));
            obj.LOTA.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), smoothedLOTA, 'uniformoutput', 0));
            % prep mean/median signals
            obj.LOTA.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), smoothedLOTA, 'uniformoutput', 0));
            obj.LOTA.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), smoothedLOTA, 'uniformoutput', 0));
            % assign RPE to each trial: (note this means RAILS signal)
            obj.LOTA.RPE = nan(numel(lick_time_next_trial),1);
            obj.LOTA.RPE(rews) = obj.LOTA.maxs(rews);
            obj.LOTA.RPE(early) = obj.LOTA.mins(early);

            if isfield(obj.LOTA,'EMG')
                EMG_LOTA = obj.LOTA.EMG.EMG_LOTA;
                % prep Rails signals
                obj.LOTA.EMG.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), EMG_LOTA, 'uniformoutput', 0));
                obj.LOTA.EMG.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), EMG_LOTA, 'uniformoutput', 0));
                % prep mean/median signals
                obj.LOTA.EMG.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), EMG_LOTA, 'uniformoutput', 0));
                obj.LOTA.EMG.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), EMG_LOTA, 'uniformoutput', 0));
                % assign RPE to each trial: (note this means RAILS signal)
                obj.LOTA.EMG.RPE = nan(numel(lick_time_next_trial),1);
                obj.LOTA.EMG.RPE(rews) = obj.LOTA.EMG.maxs(rews);
                obj.LOTA.EMG.RPE(early) = obj.LOTA.EMG.mins(early);
            end
            if isfield(obj.LOTA,'gX')
                % downsample
                X_LOTA = obj.LOTA.X.EMG_LOTA;
                % prep Rails signals
                obj.LOTA.X.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), X_LOTA, 'uniformoutput', 0));
                obj.LOTA.X.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), X_LOTA, 'uniformoutput', 0));
                % prep mean/median signals
                obj.LOTA.X.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), X_LOTA, 'uniformoutput', 0));
                obj.LOTA.X.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), X_LOTA, 'uniformoutput', 0));
                % assign RPE to each trial: (note this means RAILS signal)
                obj.LOTA.X.RPE = nan(numel(lick_time_next_trial),1);
                obj.LOTA.X.RPE(rews) = obj.LOTA.X.maxs(rews);
                obj.LOTA.X.RPE(early) = obj.LOTA.X.mins(early);
            end
            if isfield(obj.LOTA,'tdt')
                tdt_LOTA = obj.LOTA.tdt.tdt_LOTA;
                % prep Rails signals
                obj.LOTA.tdt.mins = cell2mat(cellfun(@(x) min(x(window_start_pos:window_start_pos+RPEwin)), tdt_LOTA, 'uniformoutput', 0));
                obj.LOTA.tdt.maxs = cell2mat(cellfun(@(x) max(x(window_start_pos:window_start_pos+RPEwin)), tdt_LOTA, 'uniformoutput', 0));
                % prep mean/median signals
                obj.LOTA.tdt.means = cell2mat(cellfun(@(x) mean(x(window_start_pos:window_start_pos+RPEwin)), tdt_LOTA, 'uniformoutput', 0));
                obj.LOTA.tdt.medians = cell2mat(cellfun(@(x) median(x(window_start_pos:window_start_pos+RPEwin)), tdt_LOTA, 'uniformoutput', 0));
                % assign RPE to each trial: (note this means RAILS signal)
                obj.LOTA.tdt.RPE = nan(numel(lick_time_next_trial),1);
                obj.LOTA.tdt.RPE(rews) = obj.LOTA.tdt.maxs(rews);
                obj.LOTA.tdt.RPE(early) = obj.LOTA.tdt.mins(early);
            end
        end
        function init_CTA(obj, sObj, BinningMode)
             if nargin < 3 || islogical(BinningMode) && ~BinningMode
                BinningMode = {'singletrial',17};
            elseif islogical(BinningMode) && BinningMode
                % we will pool trials on the single session obj
                BinningMode = {'times', 68};%{'custom', [0:250:3329, 3334:250:6999,7000:250:17000]};
            else
                error('BinningMode needs to be logical')
            end
            init_CTA_helper
        end
        function resetCTA(obj, RPEwin_xshift,RPEwin)
            resetCTA_helper
        end


        function init_LONTA(obj, sObj)
            %  this is lamp ON binning
            BinningMode = {'LONTA',[]};
            init_LONTA_helper
            obj.LONTA.ITISurpriseTrials = sObj.ts.ITISurpriseTrials;
        end
        function resetLONTA(obj, RPEwin_xshift,RPEwin)
            resetLONTA_helper
        end





        function [p,S, yFit, delta] = plotLTAandPredictors(obj, bins, xshift, Window, Quick)
            if nargin <5, Quick = false;end
            if nargin <3, xshift = obj.LTA.RPEwin_xshift;end
            if nargin <4, Window = obj.LTA.RPEwin;end
            if nargin <2, bins = 50;end
            obj.resetLTA(xshift,Window)

            Order = 'last-to-first';
            if strcmp(Order, 'first-to-last')
                i_minus = false;
                i_first = 1;
                binrange = 2:bins;
            else
                i_minus = true;
                i_first = bins;
                binrange = flip(1:bins-1);
            end
            idx = floor(linspace(0,numel(obj.LTA.delta_lick_time), bins+1));
            for ii=1:bins 
                % disp([num2str(idx(ii)+1) ':' num2str(idx(ii+1))])
                mean_del_lt(ii) = nanmean(obj.LTA.delta_lick_time(idx(ii)+1:idx(ii+1)));
                mean_abs_lt(ii) = nanmean(obj.LTA.lick_time_next_trial(idx(ii)+1:idx(ii+1)));
                mean_logabs_lt(ii) = nanmean(obj.LTA.log_lick_time_next_trial(idx(ii)+1:idx(ii+1))); 
            end
            Xd = [];
            ydel = mean_del_lt;
            yabs = mean_del_lt;

            if ~Quick
                if isfield(obj.LTA, 'EMG')
                    [f,ax] = makeStandardFigure(4,[1,4]);
                    EMG = obj.LTA.EMG.EMG_LTA;
                    % get even 10 blocks with numbers of trials
                    % idx = floor(linspace(0,numel(EMG), 11));
                    for ii=1:bins 
                        % disp([num2str(idx(ii)+1) ':' num2str(idx(ii+1))])
                        trials{ii} = EMG(idx(ii)+1:idx(ii+1)); 
                        means(ii) = nanmean(obj.LTA.EMG.means(idx(ii)+1:idx(ii+1)));
                        meds(ii) = nanmean(obj.LTA.EMG.medians(idx(ii)+1:idx(ii+1)));
                        RPE(ii) = nanmean(obj.LTA.EMG.RPE(idx(ii)+1:idx(ii+1)));
                    end
                    LTA = cellfun(@(x) nanmean(cell2mat(x),1),trials,'uniformoutput',0);
                    obj.plotHelperLTA(LTA,binrange,bins,'EMG',ax(1),i_first,idx,i_minus);

                    obj.plotRightScat(means,mean_abs_lt, ax(2), 'left', 'abs', 'Mean EMG', 'lick time t_n (s)', '^')
                    obj.plotRightScat(means,mean_del_lt, ax(3), 'left', 'del', 'Mean EMG', 'delta lick time t_{n} - t_{n-1} (s)', 'o')
                    obj.plotRightScat(means,mean_logabs_lt, ax(4), 'left', 'del', 'Mean EMG', 'log lick time t_{n} (s)', '<')

                    set(f, 'name', ['LTA', ' ', obj.iv.mousename_, ' Window: ' num2str(obj.LTA.RPEwin_xshift/1000) ':' num2str((obj.LTA.RPEwin_xshift+obj.LTA.RPEwin)/1000) 's post-lick'])
                    set(f, 'userdata', 'obj.plotLTAandPredictors')

                    [p,S] = polyfit(means,mean_abs_lt,2);
                    [yFit,delta] = polyval(p,means,S);
                    [sorted,I] = sort(means);
                    plot(ax(2), sorted,yFit(I)+2*delta(I),'m--',sorted,yFit(I)-2*delta(I),'m--')
                    plot(ax(2), sorted,yFit(I),'k-','linewidth', 2)

                    [rsq, yresid] = rSquared(mean_abs_lt(I), yFit(I));
                    title(ax(2),['Rsq polynomial order 2: ', num2str(rsq)])
                    figure, plot(sorted,yresid, 'o'), title('residuals, EMG fit');
                end
                if isfield(obj.LTA, 'X')
                    [f,ax] = makeStandardFigure(4,[1,4]);
                    X = obj.LTA.X.X_LTA;
                    % get even 10 blocks with numbers of trials
                    for ii=1:bins 
                        trials{ii} = X(idx(ii)+1:idx(ii+1)); 
                        means(ii) = nanmean(obj.LTA.X.means(idx(ii)+1:idx(ii+1)));
                        meds(ii) = nanmean(obj.LTA.X.medians(idx(ii)+1:idx(ii+1)));
                        RPE(ii) = nanmean(obj.LTA.X.RPE(idx(ii)+1:idx(ii+1)));
                    end
                    LTA = cellfun(@(x) nanmean(cell2mat(x),1),trials,'uniformoutput',0);
                    obj.plotHelperLTA(LTA,binrange,bins,'X',ax(1),i_first,idx,i_minus);

                    obj.plotRightScat(means,mean_abs_lt, ax(2), 'left', 'abs', 'Mean X', 'lick time t_n (s)', '^')
                    obj.plotRightScat(means,mean_del_lt, ax(3), 'left', 'del', 'Mean X', 'delta lick time t_{n} - t_{n-1} (s)', 'o')
                    obj.plotRightScat(means,mean_logabs_lt, ax(4), 'left', 'del', 'Mean X', 'log lick time t_{n} (s)', '<')

                    set(f, 'name', ['LTA', ' ', obj.iv.mousename_, ' Window: ' num2str(obj.LTA.RPEwin_xshift/1000) ':' num2str((obj.LTA.RPEwin_xshift+obj.LTA.RPEwin)/1000) 's post-lick'])
                    set(f, 'userdata', 'obj.plotLTAandPredictors')

                    [p,S] = polyfit(means,mean_abs_lt,2);
                    [yFit,delta] = polyval(p,means,S);
                    [sorted,I] = sort(means);
                    plot(ax(2), sorted,yFit(I)+2*delta(I),'m--',sorted,yFit(I)-2*delta(I),'m--')
                    plot(ax(2), sorted,yFit(I),'k-','linewidth', 2)

                    [rsq, yresid] = rSquared(mean_abs_lt(I), yFit(I));
                    title(ax(2),['Rsq polynomial order 2: ', num2str(rsq)])
                    figure, plot(sorted,yresid, 'o'), title('residuals, X fit');
                end
                if isfield(obj.LTA, 'tdt')
                    [f,ax] = makeStandardFigure(4,[1,4]);
                    tdt = obj.LTA.tdt.tdt_LTA;
                    % get even 10 blocks with numbers of trials
                    for ii=1:bins 
                        trials{ii} = tdt(idx(ii)+1:idx(ii+1)); 
                        means(ii) = nanmean(obj.LTA.tdt.means(idx(ii)+1:idx(ii+1)));
                        meds(ii) = nanmean(obj.LTA.tdt.medians(idx(ii)+1:idx(ii+1)));
                        RPE(ii) = nanmean(obj.LTA.tdt.RPE(idx(ii)+1:idx(ii+1)));
                    end
                    LTA = cellfun(@(x) nanmean(cell2mat(x),1),trials,'uniformoutput',0);
                    obj.plotHelperLTA(LTA,binrange,bins,'tdt',ax(1),i_first,idx,i_minus);

                    obj.plotRightScat(means,mean_abs_lt, ax(2), 'left', 'abs', 'Mean tdt', 'lick time t_n (s)', '^')
                    obj.plotRightScat(means,mean_del_lt, ax(3), 'left', 'del', 'Mean tdt', 'delta lick time t_{n} - t_{n-1} (s)', 'o')
                    obj.plotRightScat(means,mean_logabs_lt, ax(4), 'left', 'del', 'Mean tdt', 'log lick time t_{n} (s)', '<')

                    set(f, 'name', ['LTA', ' ', obj.iv.mousename_, ' Window: ' num2str(obj.LTA.RPEwin_xshift/1000) ':' num2str((obj.LTA.RPEwin_xshift+obj.LTA.RPEwin)/1000) 's post-lick'])
                    set(f, 'userdata', 'obj.plotLTAandPredictors')

                    [p,S] = polyfit(means,mean_abs_lt,2);
                    [yFit,delta] = polyval(p,means,S);
                    [sorted,I] = sort(means);
                    plot(ax(2), sorted,yFit(I)+2*delta(I),'m--',sorted,yFit(I)-2*delta(I),'m--')
                    plot(ax(2), sorted,yFit(I),'k-','linewidth', 2)

                    [rsq, yresid] = rSquared(mean_abs_lt(I), yFit(I));
                    title(ax(2),['Rsq polynomial order 2: ', num2str(rsq)])
                    figure, plot(sorted,yresid, 'o'), title('residuals, tdt fit');
                end
            end
            % handle the DA signal
            [f,ax] = makeStandardFigure(4,[1,4]);
            da = obj.LTA.smoothedLTA;
            % get even 10 blocks with numbers of trials
            for ii=1:bins 
                trials{ii} = da(idx(ii)+1:idx(ii+1)); 
                means(ii) = nanmean(obj.LTA.means(idx(ii)+1:idx(ii+1)));
                meds(ii) = nanmean(obj.LTA.medians(idx(ii)+1:idx(ii+1)));
                RPE(ii) = nanmean(obj.LTA.RPE(idx(ii)+1:idx(ii+1)));
            end
            LTA = cellfun(@(x) nanmean(cell2mat(x),1),trials,'uniformoutput',0);
            obj.plotHelperLTA(LTA,binrange,bins,'DA',ax(1),i_first,idx,i_minus);
            obj.plotRightScat(means,mean_abs_lt, ax(2), 'left', 'abs', 'Mean DA', 'lick time t_n (s)', '^')
            obj.plotRightScat(means,mean_del_lt, ax(3), 'left', 'del', 'Mean DA', 'delta lick time t_{n} - t_{n-1} (s)', 'o')
            obj.plotRightScat(means,mean_logabs_lt, ax(4), 'left', 'del', 'Mean DA', 'log lick time t_{n} (s)', '<')

            set(f, 'name', ['LTA', ' ', obj.iv.mousename_, ' Window: ' num2str(obj.LTA.RPEwin_xshift/1000) ':' num2str((obj.LTA.RPEwin_xshift+obj.LTA.RPEwin)/1000) 's post-lick'])
            set(f, 'userdata', 'obj.plotLTAandPredictors')

            % let's try a polynomial fit...
            [p,S] = polyfit(means,mean_abs_lt,2);
            [yFit,delta] = polyval(p,means,S);
            [sorted,I] = sort(means);
            plot(ax(2), sorted,yFit(I)+2*delta(I),'m--',sorted,yFit(I)-2*delta(I),'m--')
            plot(ax(2), sorted,yFit(I),'k-','linewidth', 2)

            [rsq, yresid] = rSquared(mean_abs_lt(I), yFit(I));
            title(ax(2),['Rsq polynomial order 2: ', num2str(rsq)])
            figure, plot(sorted,yresid, 'o'), title('residuals, DA fit');

            
        end
        function plotHelperLTA(obj, LTA,binrange,bins, SignalType, ax,i_first,idx,i_minus)
            xticks = obj.LTA.xticks_s;
            yMin = nanmin(nanmin(cell2mat(LTA')));
            yMax = nanmax(nanmax(cell2mat(LTA')));
            plot(ax,[0,0],[yMin, yMax], 'k-', 'linewidth',3,'DisplayName', 'Lick')
            C = linspecer(length(1:bins));
            C(2:end-1) = C(2:end-1)-0.1;
            C(C<0) = 0;
            C = flipud(C);
            % ax = axes('NextPlot','replacechildren', 'ColorOrder',C);
            set(ax,'NextPlot','replacechildren', 'ColorOrder',C);
            hold(ax,'on')
            plot(ax,xticks,LTA{i_first}, 'linewidth',3, 'DisplayName',['ti ' num2str(idx(i_first)) ':' num2str(idx(i_first+1))])
            if i_minus
                for ibin = binrange, plot(ax, xticks, LTA{ibin}, 'linewidth',3,'DisplayName', ['ti ' num2str(idx(ibin)) ':' num2str(idx(ibin+1))]), end

            else
                for ibin = binrange, plot(ax,xticks, LTA{ibin},'linewidth',3,'DisplayName', ['ti ' num2str(idx(ibin)) ':' num2str(idx(ibin+1))]), end
            end
            xlim(ax,[-5, 10])
            title(ax,['LTA: ', SignalType])
            xlabel(ax,'Time wrt First Lick (s)')
            if strcmpi(SignalType, 'EMG')
                ylabel(ax,'EMG')
            elseif strcmpi(SignalType, 'X')
                ylabel(ax,'Accel')
            else
                ylabel(ax,'dF/F')
            end
            legend(ax, 'show');
        end
        function plotRightScat(obj, x,y, ax, LR, DisplayName, xl, yl, Marker)
            if strcmpi(LR, 'right'), yyaxis(ax,'right'); end
            C = linspecer(numel(x));
            C(2:end-1) = C(2:end-1)-0.1;
            C(C<0) = 0;
            C = flipud(C);
            set(ax,'NextPlot','replacechildren', 'ColorOrder',C);
            hold(ax,'on')
            xlabel(ax,xl)
            ylabel(ax,yl)
            for ii = flip(1:numel(x))
                if ii == 1
                    scatter(ax, x(ii),y(ii),50,Marker,'filled', 'displayname', DisplayName);
                else
                    scatter(ax, x(ii),y(ii),50,Marker,'filled', 'handlevisibility', 'off');
                end
            end 
            legend(ax,'show')
            if strcmpi(LR, 'right'), yyaxis(ax, 'left'); end
        end
        function plotSignalVsLickTime(obj, Mode)
            %             
            %  This plots Rails, Mean and Median signal vs Lick Time on
            %  trial n. Mode is either 'LOTA' or 'LTA' or 'compositeLOTA'
            %   LTA-ratio
            % 
            if nargin < 2
                Mode = 'LTA';
            end
            [f,ax] = makeStandardFigure(3,[1,3]);
            if strcmpi(Mode, 'LOTA') || strcmpi(Mode, 'LOTA-EMG')
                if obj.iv.compositeMode, warning('you should be using compositeLOTA mode to plot wrt UPCOMING trial...'), end
                lick_time = obj.LOTA.lick_time;
                RPEwin_xshift = obj.LOTA.RPEwin_xshift;
                RPEwin = obj.LOTA.RPEwin;
                if strcmpi(Mode, 'LOTA')
                    RPE = obj.LOTA.RPE;
                    means = obj.LOTA.means;
                    medians = obj.LOTA.medians;
                elseif strcmpi(Mode, 'LOTA-EMG')
                    RPE = obj.LOTA.EMG.RPE;
                    means = obj.LOTA.EMG.means;
                    medians = obj.LOTA.EMG.medians;
                end
                rews = obj.LOTA.rews;
                early = obj.LOTA.early;
                ylabel(ax(1),['Rails dF/F: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'])
                title(ax(1),'Rails pre-LOTA')
                ylabel(ax(2),['Mean dF/F: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'])
                title(ax(2),'mean pre-LOTA')
                ylabel(ax(3),['Median dF/F: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'])
                title(ax(3),'median pre-LOTA')
                Name = [Mode, ' ', obj.iv.mousename_, ' Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'];
                if iscell(Name), Name = cell2mat(Name);end
                set(f, 'name', Name)
            elseif strcmpi(Mode, 'compositeLOTA') || strcmpi(Mode, 'compositeLOTA-EMG')
                % 
                %   here we want to plot wrt next trial
                % 
                lick_time = obj.LOTA.lick_time_next_trial;
                RPEwin_xshift = obj.LOTA.RPEwin_xshift;
                RPEwin = obj.LOTA.RPEwin;
                if strcmpi(Mode, 'compositeLOTA')
                    RPE = obj.LOTA.RPE;
                    means = obj.LOTA.means;
                    medians = obj.LOTA.medians;
                elseif strcmpi(Mode, 'compositeLOTA-EMG')
                    RPE = obj.LOTA.EMG.RPE;
                    means = obj.LOTA.EMG.means;
                    medians = obj.LOTA.EMG.medians;
                end
                if ~isempty(obj.LOTA.rews)
                    rews = obj.LOTA.rews;
                    early = obj.LOTA.early;
                else
                    rews = [];
                    early = 1:numel(obj.LOTA.lick_time_next_trial);
                end
                ylabel(ax(1),['Rails dF/F: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'])
                title(ax(1),'Rails pre-LOTA')
                ylabel(ax(2),['Mean dF/F: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'])
                title(ax(2),'mean pre-LOTA')
                ylabel(ax(3),['Median dF/F: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'])
                title(ax(3),'median pre-LOTA')
                Name = [Mode, ' ', obj.iv.mousename_, ' ' obj.iv.signalname ' ' obj.iv.daynum_ ' Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'];
                if iscell(Name), Name = cell2mat(Name);end
                set(f, 'name', Name)
            elseif  strcmpi(Mode, 'LTA-ratio')
                lick_time = obj.LTA.lick_time.*1000;
                lick_time(lick_time<700) = nan;
                lick_time_next = obj.LTA.lick_time_next_trial.*1000;
                lick_time_next(lick_time_next<700) = nan;
                ratio = (lick_time-lick_time_next)./(lick_time_next.*lick_time);%(lick_time_next-lick_time)./(lick_time_next+lick_time);%lick_time_next./lick_time;
                means = obj.LTA.means;
                rews = obj.LTA.rews;
                early = obj.LTA.early;
                plot(ax(1), means(rews),ratio(rews), 'g.', 'markersize', 20);
                plot(ax(1), means(early),ratio(early), 'k.', 'markersize', 20);
                glm = fitglm(means, ratio');
                warning('EDIT HERE')
                return
            elseif strcmpi(Mode, 'LTA') || strcmpi(Mode, 'LTA-EMG')
                lick_time = obj.LTA.lick_time;
                RPEwin_xshift = obj.LTA.RPEwin_xshift;
                RPEwin = obj.LTA.RPEwin;
                if strcmpi(Mode, 'LTA')
                    RPE = obj.LTA.RPE;
                    means = obj.LTA.means;
                    medians = obj.LTA.medians;
                elseif strcmpi(Mode, 'LTA-EMG')
                    RPE = obj.LTA.EMG.RPE;
                    means = obj.LTA.EMG.means;
                    medians = obj.LTA.EMG.medians;
                end
                rews = obj.LTA.rews;
                early = obj.LTA.early;
                ylabel(ax(1),['Rails dF/F: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's post-lick'])
                title(ax(1),'Rails post-Lick n')
                ylabel(ax(2),['Mean dF/F: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's post-lick'])
                title(ax(2),'mean post-Lick n')
                ylabel(ax(3),['Median dF/F: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's post-lick'])
                title(ax(3),'median post-Lick n')
                Name = [Mode, ' ', obj.iv.mousename_, ' ' obj.iv.signalname ' ' obj.iv.daynum_ ' Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's post-lick'];
                if iscell(Name), Name = cell2mat(Name);end
                set(f, 'name', Name)
            else
                error('Mode is LOTA or LTA');
            end
            plot(ax(1),lick_time(rews), RPE(rews), 'g.', 'markersize', 20);
            plot(ax(1),lick_time(early), RPE(early), 'k.', 'markersize', 20);
            plot(ax(2),lick_time(rews), means(rews), 'g.', 'markersize', 20);
            plot(ax(2),lick_time(early), means(early), 'k.', 'markersize', 20);
            plot(ax(3),lick_time(rews), medians(rews), 'g.', 'markersize', 20);
            plot(ax(3),lick_time(early), medians(early), 'k.', 'markersize', 20);
            for ii = 1:3
                if ~strcmpi(Mode, 'compositeLOTA') && ~strcmpi(Mode, 'compositeLOTA-EMG')
                    xlabel(ax(ii),'lick time, trial n')
                else
                    xlabel(ax(ii),'lick time, trial n+1')
                end
            end
            set(f, 'userdata', ['obj.plotSignalVsLickTime(Mode:', Mode ', sm:' obj.iv.smoothing, ', file:' obj.iv.savefilename]); 
        end
        function [trialsIncluded, trialsNotIncluded] = getQuantilesOfTrials(obj, Qno_to_get, nquantiles, fLick_trial_num,sorted_trial_num)
            % store this somewhere in obj so we know what used...
            if nargin < 3, nquantiles = 4;warning('using quartiles');end
            iQ = Qno_to_get;
            iipart = iQ;
            p1Idx = 1+floor(numel(fLick_trial_num)/nquantiles)*(iipart-1);
            if iipart == nquantiles
                p2Idx = numel(fLick_trial_num);
            else
                p2Idx = floor(numel(fLick_trial_num)/nquantiles)*(iipart);
            end
            disp(['div#' num2str(iipart) ':' num2str(p1Idx) '-' num2str(p2Idx)])
            trialsIncluded = sorted_trial_num(p1Idx:p2Idx);
            trialsNotIncluded = ~ismember(fLick_trial_num, trialsIncluded);

        end
        function [B,DEV,STATS, yfit, rsq, resid,ModelPacket, Signal,y, mdl, excl] = fitModel(obj, Mode, Model, Signal, normalizeX, Early_or_Rew_conditioning, stimOnly, yinput)
            %   Fits the following models for Mode = LTA or LOTA or outcome:
            %       
            %       Mode:
            %               stim: like the outcome model, but uses stim as predictor
            %
            %               outcome: uses the previous trial outcome as predictor
            %               outcome-x-tdt
            %               outcome-emg-tdt
            %               outcome-x-emg-tdt
            %
            %               LTA: uses post-lick signal as stored in obj
            %               LTA-outcome: includes outcome in LTA model
            %               LTA-EMG: uses EMG version
            %               LTA-tdt: uses tdt version
            %               LTA-X: uses X version
            %               LOTA: uses pre-lamp-off signal as stored in obj
            %               LOTA-EMG: uses EMG version
            %               LOTA-tdt: uses tdt version
            %               LOTA-X: uses X version
            %               
            %               LTA-EMG-tdt: just uses move ctrls
            %               LTA-X-tdt: just uses move ctrls
            %               LTA-X-EMG-tdt: just uses move ctrls
            %
            %               LTA-&-EMG: uses both predictors
            %               LTA-&-tdt: uses both predictors
            %               LTA-&-X: uses both
            %               LOTA-&-EMG: uses both predictors
            %               LOTA-&-tdt: uses both predictors
            %               LOTA-&-X: uses both
            %
            %               LTA-&-EMG-&-tdt: uses 3 predictors
            %               LTA-&-X-&-tdt: uses 3 predictors
            %               LOTA-&-EMG-&-tdt: uses 3 predictors
            %               LOTA-&-X-&-tdt: uses 3 predictors
            %               
            %               LTA-&-EMG-&-X-&-tdt: uses 4 predictors
            %               LOTA-&-EMG-&-X-&-tdt: uses 4 predictors
            %               
            %
            %       Model: 
            %               del: uses the difference in lick-times (n+1) - n
            %               abs: uses the true lick time on (n+1)
            %               logabs: uses the log of the true lick time on (n+1)
            %               delmed: (NEW! 12/21/24)
            %       
            %       Signal:
            %               rails: uses value stored in "RPE"
            %               mean: uses value stored in means
            %               median: uses value stored in medians
            %
            %             
            if nargin < 8, yinput = [];end
            % if ~isempty(yinput), warning('rbf! I left off here. we need to test if we can input yinput directly'), end
            if nargin < 7, stimOnly = false;end
            if nargin < 6, Early_or_Rew_conditioning = 'none'; end
            if nargin < 5
                normalizeX = false;
            end
            
            % this calls the helper script where all the model strings are parsed
            fitModelHelper_sloshingModel

            if isempty(yinput)
                % if sum(size(y)==size(Signal))~=2, y=y';end 
                if size(y,1)~=size(Signal,1), y=y';end 
                if iscell(y), y=cell2mat(y);end


                % if we are doing some kind of early or reward conditioning, we need to now mask x to only predict on the desired trial category
                if contains(Early_or_Rew_conditioning, 'early')
                    % predict on only the early trials for the current trial
                    y(obj.LTA.lick_time >= 3.333) = nan;
    %                 if normalizeX, obj.normSig(y);end
                elseif contains(Early_or_Rew_conditioning, 'reward')
                    % predict on only the rewarded trials for the current trial
                    y(obj.LTA.lick_time < 3.333 | obj.LTA.lick_time > 7) = nan;
    %                 if normalizeX, obj.normSig(y);end
                
                elseif ~contains(Early_or_Rew_conditioning, 'Q') && ~strcmpi(Early_or_Rew_conditioning, 'none') && ~contains(Early_or_Rew_conditioning, '{')
                    error('Early_or_Rew_conditioning can only be none, early or reward, or Q1 Q1-early Q1-reward... or {1,5}-early')
                end

                if stimOnly
                    y(obj.LTA.nostimIdx) = nan;
    %                 if normalizeX, obj.normSig(y);end
                end

                if contains(Early_or_Rew_conditioning, 'Q') % possibles: Q1 Q2 Q3 Q4 Q1-early Q2-reward, etc
                    % warning('partition method only configured for LTA mode right now, 4 partitions (quartiles)')
                    npartitions = 4;
                    fLick_trial_num = cell2mat(obj.LTA.trials_in_each_bin);
                    sorted_trial_num = sort(fLick_trial_num);
                    if contains(Early_or_Rew_conditioning, 'Q1')
                        iipart = 1;
                    elseif contains(Early_or_Rew_conditioning, 'Q2')
                        iipart = 2;
                    elseif contains(Early_or_Rew_conditioning, 'Q3')
                        iipart = 3;
                    elseif contains(Early_or_Rew_conditioning, 'Q4')  
                        iipart = 4;   
                    else
                        error('must be Q1 Q2 Q3 or Q4 or these -early or -reward')
                    end
                    if obj.iv.humanMode
                        warning('we are making Q1 beginner, Q2 intermediate, Q3-4 expert trials 1:34')
                        p1Idx = 1+floor(68/npartitions)*(iipart-1);
                        if iipart == npartitions
                            p2Idx = 68;
                        else
                            p2Idx = floor(68/npartitions)*(iipart);
                        end
                    else
                        p1Idx = 1+floor(numel(fLick_trial_num)/npartitions)*(iipart-1);
                        if iipart == npartitions
                            p2Idx = numel(fLick_trial_num);
                        else
                            p2Idx = floor(numel(fLick_trial_num)/npartitions)*(iipart);
                        end
                    end
                    % disp(['div#' num2str(iipart) ':' num2str(p1Idx) '-' num2str(p2Idx)])
                    trialsIncluded = sorted_trial_num(p1Idx:p2Idx);
                    trialsNotIncluded = ~ismember(fLick_trial_num, trialsIncluded);

                    % set to nan anything not in included trials
                    y(trialsNotIncluded) = nan;
                end
                if contains(Early_or_Rew_conditioning, '{')
                    % quantiles the original way...first number is which quantile out of how many
                    % eg {1,5} -- first out of 5
                    % get the quantiles out: 
                    fLick_trial_num = cell2mat(obj.LTA.trials_in_each_bin);
                    sorted_trial_num = sort(fLick_trial_num);
                    QQ = strsplit(Early_or_Rew_conditioning, '-');
                    QQ(~contains(QQ,'{')) = [];
                    QQ = eval(QQ{1});
                    [trialsIncluded, trialsNotIncluded] = obj.getQuantilesOfTrials(QQ{1}, QQ{2}, fLick_trial_num,sorted_trial_num);
                    y(trialsNotIncluded) = nan;
                end
            else
                % use yinput
                warning('we specified y at the function call. this should only be used for regressing away stuff 7-7-24')
                y = yinput;
            end


            % Switching to fitglm method: I investigated this on 6/13/23, as many of the old runners were still using glmfit, which used my rsq fxn. 
            % mine mut have an issue with missing data (nan), where it still seems to inflate the rsq for rails (it's about double for both LTA and LOTA models)
            % We will trust the fitglm method. I verified everything else was identical between the two versions except rsq for rails. 
            % 

            % fitglm methods: introduced from elsewhere in file on 6/13/23
            Theta_Names = obj.getThetaNames(Mode, RPEwin_xshift, RPEwin);
            % Theta_Names = obj.getThetaNames(ModelName, xshift, Window); %  <-og
            Theta_Names_short = cellfun(@(x) x{1}, cellfun(@(x) strsplit(x,' '), Theta_Names, 'uniformoutput', 0), 'uniformoutput', 0);
            t = table(y, ones(numel(Signal(:,1)),1), 'VariableNames', {Model, Theta_Names_short{1}});
            % t = table(y, ones(numel(Signal(:,1)),1), 'VariableNames', {Signal, Theta_Names_short{1}});
            for iii = 1:numel(Theta_Names_short(2:end))
                name = Theta_Names_short(1+iii);
                t = addvars(t,Signal(:,iii), 'NewVariableNames', name);
            end

            modelspec = cell2mat([Model,'~',Theta_Names_short{1}, cellfun(@(x) ['+',x],Theta_Names_short(2:end), 'uniformoutput',0)]);
            % modelspec = cell2mat([Signal,'~',Theta_Names_short{1}, cellfun(@(x) ['+',x],Theta_Names_short(2:end), 'uniformoutput',0)]);

            % prune the table
            excl = find(isnan(t{:,1}));
%             y(excl) = [];
            % renormalize
            for ii = 2:size(t,2)
                t{isnan(t{:,1}),ii} = nan; 
                if normalizeX && ii>2
                    t(:,ii) = table(t{:,ii} - min(t{:,ii}));
                    t(:,ii) = table(t{:,ii}./max(t{:,ii}));
                end
            end
            
            mdl = fitglm(t,modelspec,'Distribution','normal','intercept',false);
            % drag along the window of the fit...
            ModelDeets.xshift = RPEwin_xshift;
            ModelDeets.window = RPEwin;
            B = mdl.Coefficients.Estimate;
            STATS.se = mdl.Coefficients.SE;
            STATS.dfe = mdl.DFE;
            DEV = mdl.Deviance;

            STATS.p = mdl.Coefficients.pValue(end);
            rsq = mdl.Rsquared.Ordinary;
            yfit = mdl.Fitted.Response;
            resid = mdl.Residuals.Raw;
            % original glmfit methods: swapped out 6/13/23 -----------------it inflates rsq on rails!------------------
            % [B,DEV,STATS] = glmfit(Signal, y, 'normal');
            % yfit = [ones(size(Signal,1),1),Signal]*STATS.beta;
            % [rsq,resid] = rSquared(y,yfit);
            % % add this so will run with the new mdl field: 
            % mdl = [];
            %---------------------------------------------------------------------------------

            if contains(Mode, 'LTA')% || strcmpi(Mode, 'LTA-&-EMG') || strcmpi(Mode, 'LTA-&-tdt') || strcmpi(Mode, 'LTA-&-EMG-&-tdt')
                if numel(obj.LTA.Models) == 1, ii = 1; else, ii=numel(obj.LTA.Models)+1; end
                ModelDeets.ModelType = 'LTA';
                obj.LTA.Models(ii).Model = Model;
                obj.LTA.Models(ii).Signal = Signal;
                obj.LTA.Models(ii).Window = [RPEwin_xshift/1000, RPEwin_xshift/1000+RPEwin/1000];
                obj.LTA.Models(ii).B = B;
                obj.LTA.Models(ii).DEV = DEV;
                obj.LTA.Models(ii).STATS = STATS;
                obj.LTA.Models(ii).yfit = yfit;
                obj.LTA.Models(ii).rsq = rsq;
                obj.LTA.Models(ii).resid = resid;
                obj.LTA.Models(ii).mdl = mdl;
            elseif contains(Mode, 'LOTA') %|| strcmpi(Mode, 'LOTA-&-EMG') || strcmpi(Mode, 'LOTA-&-tdt') || strcmpi(Mode, 'LOTA-&-EMG-&-tdt')
                if numel(obj.LOTA.Models) == 1, ii = 1; else, ii=numel(obj.LOTA.Models)+1; end
                ModelDeets.ModelType = 'LOTA';
                obj.LOTA.Models(ii).Model = Model;
                obj.LOTA.Models(ii).Signal = Signal;
                obj.LOTA.Models(ii).Window = [RPEwin_xshift/1000, RPEwin_xshift/1000+RPEwin/1000];
                obj.LOTA.Models(ii).B = B;
                obj.LOTA.Models(ii).DEV = DEV;
                obj.LOTA.Models(ii).STATS = STATS;
                obj.LOTA.Models(ii).yfit = yfit;
                obj.LOTA.Models(ii).rsq = rsq;
                obj.LOTA.Models(ii).resid = resid;  
                obj.LOTA.Models(ii).mdl = mdl; 
            elseif contains(Mode, 'CTA')
                if numel(obj.CTA.Models) == 1, ii = 1; else, ii=numel(obj.CTA.Models)+1; end
                ModelDeets.ModelType = 'CTA';
                obj.CTA.Models(ii).Model = Model;
                obj.CTA.Models(ii).Signal = Signal;
                obj.CTA.Models(ii).Window = [RPEwin_xshift/1000, RPEwin_xshift/1000+RPEwin/1000];
                obj.CTA.Models(ii).B = B;
                obj.CTA.Models(ii).DEV = DEV;
                obj.CTA.Models(ii).STATS = STATS;
                obj.CTA.Models(ii).yfit = yfit;
                obj.CTA.Models(ii).rsq = rsq;
                obj.CTA.Models(ii).resid = resid;
                obj.CTA.Models(ii).mdl = mdl; 
            elseif contains(Mode, 'outcome')% || strcmpi(Mode, 'LTA-&-EMG') || strcmpi(Mode, 'LTA-&-tdt') || strcmpi(Mode, 'LTA-&-EMG-&-tdt')
                if numel(obj.LTA.Models) == 1, ii = 1; else, ii=numel(obj.LTA.Models)+1; end
                ModelDeets.ModelType = 'outcome';
                obj.LTA.Models(ii).Model = Model;
                obj.LTA.Models(ii).Signal = Signal;
                obj.LTA.Models(ii).Window = [RPEwin_xshift/1000, RPEwin_xshift/1000+RPEwin/1000];
                obj.LTA.Models(ii).B = B;
                obj.LTA.Models(ii).DEV = DEV;
                obj.LTA.Models(ii).STATS = STATS;
                obj.LTA.Models(ii).yfit = yfit;
                obj.LTA.Models(ii).rsq = rsq;
                obj.LTA.Models(ii).resid = resid;
                obj.LTA.Models(ii).mdl = mdl;
            else
                error('shouldnt get here')
            end

            ModelPacket.Model = Model;
            ModelPacket.Signal = Signal;
            ModelPacket.Window = [RPEwin_xshift/1000, RPEwin_xshift/1000+RPEwin/1000];
            ModelPacket.y = y;
            ModelPacket.B = B;
            ModelPacket.DEV = DEV;
            ModelPacket.STATS = STATS;
            ModelPacket.yfit = yfit;
            ModelPacket.rsq = rsq;
            ModelPacket.resid = resid;
            ModelPacket.mdl = mdl;
            ModelPacket.ModelDeets = ModelDeets;
        end
        function normSig = normSig(obj,Signal)
            normSig = (Signal - min(Signal))/(max(Signal) - min(Signal));
        end
        function plotModel(obj,x,y,yfit,early, rews,STATS,rsq,Title,Xl, Yl, ax)
            if iscell(y), y=cell2mat(y);end
            plot(ax,x, y, 'k.', 'markersize', 20, 'handlevisibility', 'off');
            plot(ax,x(rews), y(rews), 'g.', 'markersize', 20, 'displayname', 'prev reward');
            plot(ax,x(early), y(early), 'r.', 'markersize', 20, 'displayname', 'prev early');
            if isfield(obj.LTA,'stimIdx')
                plot(ax,x(obj.LTA.stimIdx), y(obj.LTA.stimIdx), '.', 'color', [0.9, 0.8,0], 'markersize', 10, 'displayname', 'stim');
                plot(ax,x(obj.LTA.nostimIdx), y(obj.LTA.nostimIdx), '.','color', [0.2, 0.2, 0.2], 'markersize', 10, 'displayname', 'nostim');
            end
            plot(ax,x, yfit, 'b.', 'markersize', 20,'displayname', ['p=' num2str(STATS.p(end)) ' rsq=', num2str(rsq)]);
            xlabel(ax,Xl)
            ylabel(ax,Yl)
            title(ax,Title)
            legend(ax,'show', 'location', 'best')
        end
        function plotCoeff(obj,Models,Theta_Names,Title,Yl, ax)
            [meanTh, ~, ~, CImin, CImax] = obj.getCompositeTheta(Models);
            
            for ii = 1:numel(Theta_Names)
                plot(ax,ii, meanTh(ii), 'r.', 'markersize', 20, 'displayname', Theta_Names{ii});
                plotCIbar(ax,ii,meanTh(ii),[CImin(ii),CImax(ii)],[]);
            end
            plot(ax, [0,numel(meanTh)+1],[0,0], 'handlevisibility', 'off'); 
%             xlabel(ax,Xl)
            xticks(ax,1:numel(meanTh));
            xticklabels(ax, Theta_Names);
            ylabel(ax,Yl)
            if ~isempty(Title)
                title(ax,Title)
            end
            legend(ax,'show', 'location', 'best') 
        end
        function [meanTh, propagated_se_th, mdf, CImin, CImax] = getCompositeTheta(obj, Models)
            % 
            %   Models is cell array with each of the models
            %       Where model is the field with the results of the fit. 
            % 
            % extract the thetas
            ths = {};
            se_ths = {};
            dfs = [];
            for imodel = 1:numel(Models)
                ths{imodel,1} = Models(imodel).B;
                se_ths{imodel,1} = Models(imodel).STATS.se;
                dfs(imodel,1) = Models(imodel).STATS.dfe;
            end
            ths = cell2mat(ths)';
            se_ths = cell2mat(se_ths)';
            N = numel(Models);
            NN = N.*ones(1, size(ths, 2));
            
            
            meanTh = 1/N .* nansum(ths, 1);
            propagated_se_th = 1/N .* sqrt(nansum(se_ths.^2, 1));
            mdf = sum(dfs).*ones(1, size(meanTh,2));
            % 
            %   Now, calculate the CI = b +/- t(0.025, n(m-1))*se
            % 
            for nn = 1:size(meanTh, 2)
                CImin(nn) = meanTh(nn) - abs(tinv(.025,numel(NN(nn))*(mdf(nn) - 1))).*propagated_se_th(nn);
                CImax(nn) = meanTh(nn) + abs(tinv(.025,numel(NN(nn))*(mdf(nn) - 1))).*propagated_se_th(nn);
            end
            % note: theta in rows here, cols are min and 
            obj.analysis.flush.meanTh = meanTh;
            obj.analysis.flush.propagated_se_th = propagated_se_th;
            obj.analysis.flush.mdf = mdf;
            obj.analysis.flush.N = NN;
            obj.analysis.flush.CImin = CImin;
            obj.analysis.flush.CImax = CImax;
        end
        function useMask(obj, rewOnly, earlyOnly)
            if nargin < 3
                earlyOnly = false;
            end
            if nargin < 2
                rewOnly = false;
            end
            % 
            %   This trims off any lick times >7s on the next trial
            % 
            
            if ~isempty(obj.LOTA)
                % if we binned by 68 exclude the overlapping time
                % mask68 = false;
                % if strcmpi(obj.LOTA.BinningMode{1}, 'times')
                %     if obj.LOTA.BinningMode{2} == 68
                %         mask68 = true;
                %     end
                % end
                %.............................. OG
                % warning('Mask applied. Only lick times <7s on next trial considered')
                % sloshmask = obj.LOTA.lick_time_next_trial<7;% & obj.LOTA.lick_time_next_trial>1; warning('We''re excluding Rxns you may want to turn this off!')
                % % if mask68, sloshmask(14) = 0;end
                % obj.LOTA.RPE = obj.LOTA.RPE(sloshmask);
                % obj.LOTA.means = obj.LOTA.means(sloshmask);
                % obj.LOTA.medians = obj.LOTA.medians(sloshmask);
                % obj.LOTA.prev_trial = obj.LOTA.prev_trial(sloshmask);
                % obj.LOTA.lick_time = obj.LOTA.lick_time(sloshmask);
                % obj.LOTA.lick_time_next_trial = obj.LOTA.lick_time_next_trial(sloshmask);
                % obj.LOTA.next_trial = obj.LOTA.next_trial(sloshmask);
                % obj.LOTA.log_lick_time_next_trial = obj.LOTA.log_lick_time_next_trial(sloshmask);
                % obj.LOTA.delta_lick_time = obj.LOTA.delta_lick_time(sloshmask);

                % % handle move controls
                % if isfield(obj.LOTA, 'EMG')
                %     obj.LOTA.EMG.medians = obj.LOTA.EMG.medians(sloshmask);
                %     obj.LOTA.EMG.means = obj.LOTA.EMG.means(sloshmask);
                %     obj.LOTA.EMG.RPE = obj.LOTA.EMG.RPE(sloshmask);
                % end
                % if isfield(obj.LOTA, 'tdt')
                %     obj.LOTA.tdt.medians = obj.LOTA.tdt.medians(sloshmask);
                %     obj.LOTA.tdt.means = obj.LOTA.tdt.means(sloshmask);
                %     obj.LOTA.tdt.RPE = obj.LOTA.tdt.RPE(sloshmask);
                % end
                % if isfield(obj.LOTA, 'X')
                %     obj.LOTA.X.medians = obj.LOTA.X.medians(sloshmask);
                %     obj.LOTA.X.means = obj.LOTA.X.means(sloshmask);
                %     obj.LOTA.X.RPE = obj.LOTA.X.RPE(sloshmask);
                % end
                % sloshmask = find(obj.LOTA.lick_time_next_trial<7);
                % % if mask68, sloshmask= [sloshmask,14];end
                % obj.LOTA.early(obj.LOTA.early>numel(obj.LOTA.lick_time_next_trial)) = [];
                % obj.LOTA.rews(obj.LOTA.rews>numel(obj.LOTA.lick_time_next_trial)) = [];
                %...............................
                sloshmask = obj.LOTA.lick_time_next_trial>=7;% & obj.LOTA.lick_time_next_trial<1; warning('We''re excluding Rxns you may want to turn this off!')
                obj.LOTA.lick_time(sloshmask) = nan;
                obj.LOTA.lick_time_next_trial(sloshmask) = nan;
                obj.LOTA.log_lick_time_next_trial(sloshmask) = nan;
                obj.LOTA.delta_lick_time(sloshmask) = nan;
            end
            if ~isempty(obj.LTA)
                % mask68 = false;
                % if strcmpi(obj.LTA.BinningMode{1}, 'times')
                %     if obj.LTA.BinningMode{2} == 68
                %         mask68 = true;
                %     end
                % end
                % warning('Mask applied. Only lick times <7s on this (lick-aligned) trial considered')
                % OG...................................
                % sloshmask = obj.LTA.lick_time<7;
                % if rewOnly, sloshmask(obj.LTA.lick_time<3.3) = false;end
                % % if mask68, sloshmask(14) = 0;end
                % obj.LTA.trials_in_each_bin = obj.LTA.trials_in_each_bin(sloshmask);
                % obj.LTA.RPE = obj.LTA.RPE(sloshmask);
                % obj.LTA.means = obj.LTA.means(sloshmask);
                % obj.LTA.medians = obj.LTA.medians(sloshmask);
                % obj.LTA.lick_time = obj.LTA.lick_time(sloshmask);
                % obj.LTA.lick_time_next_trial = obj.LTA.lick_time_next_trial(sloshmask);
                % obj.LTA.next_trial = obj.LTA.next_trial(sloshmask);
                % obj.LTA.log_lick_time_next_trial = obj.LTA.log_lick_time_next_trial(sloshmask);
                % obj.LTA.delta_lick_time = obj.LTA.delta_lick_time(sloshmask);

                % % handle move controls
                % if isfield(obj.LTA, 'EMG')
                %     obj.LTA.EMG.medians = obj.LTA.EMG.medians(sloshmask);
                %     obj.LTA.EMG.means = obj.LTA.EMG.means(sloshmask);
                %     obj.LTA.EMG.RPE = obj.LTA.EMG.RPE(sloshmask);
                % end
                % if isfield(obj.LTA, 'tdt')
                %     obj.LTA.tdt.medians = obj.LTA.tdt.medians(sloshmask);
                %     obj.LTA.tdt.means = obj.LTA.tdt.means(sloshmask);
                %     obj.LTA.tdt.RPE = obj.LTA.tdt.RPE(sloshmask);
                % end
                % if isfield(obj.LTA, 'X')
                %     obj.LTA.X.medians = obj.LTA.X.medians(sloshmask);
                %     obj.LTA.X.means = obj.LTA.X.means(sloshmask);
                %     obj.LTA.X.RPE = obj.LTA.X.RPE(sloshmask);
                % end
                
                % if rewOnly
                %     sloshmask = find(obj.LTA.lick_time<7 & obj.LTA.lick_time>3.3);
                %     obj.LTA.early = [];
                %     obj.LTA.rews = sloshmask;
                % else
                %     sloshmask = find(obj.LTA.lick_time<7);
                %     obj.LTA.early(obj.LTA.early>numel(obj.LTA.lick_time_next_trial)) = [];
                %     obj.LTA.rews(obj.LTA.rews>numel(obj.LTA.lick_time_next_trial)) = [];
                % end
                %.............................................
                % if mask68, sloshmask= [sloshmask;14];end
                sloshmask = obj.LTA.lick_time>=7;
                if rewOnly, sloshmask(obj.LTA.lick_time<3.333) = true;end
                if earlyOnly, sloshmask(obj.LTA.lick_time>3.333) = true;end
                % if mask68, sloshmask(14) = 0;end
                obj.LTA.lick_time(sloshmask) = nan;
                obj.LTA.lick_time_next_trial(sloshmask) = nan;
                obj.LTA.log_lick_time_next_trial(sloshmask) = nan;
                obj.LTA.delta_lick_time(sloshmask) = nan;                
                
            end
            if ~isempty(obj.CTA)
                sloshmask = obj.CTA.lick_time>=7;
                if rewOnly, sloshmask(obj.CTA.lick_time<3.333) = true;end
                if earlyOnly, sloshmask(obj.CTA.lick_time>3.333) = true;end
                % if mask68, sloshmask(14) = 0;end
                obj.CTA.lick_time(sloshmask) = nan;
                obj.CTA.lick_time_next_trial(sloshmask) = nan;
                obj.CTA.log_lick_time_next_trial(sloshmask) = nan;
                obj.CTA.delta_lick_time(sloshmask) = nan;                
            end

        end
        function [Name,mdls] = runAllModelsAndPlot(obj,Mode,normalizeX,useMask, stimOnly, Early_or_Rew_conditioning)
            %             
            %  Mode is LTA or LOTA. Uses stored params. 
            %       useMask will limit the window of consideration to signals where the lick time on the next trial was within the timing range (0-7s)
            % 
            if nargin < 6, Early_or_Rew_conditioning = 'none';end
            if nargin < 5
                stimOnly = false;
            end
            if nargin < 4
                useMask = false;
            end
            if nargin <3
                normalizeX = false;
            end
            if useMask
                obj.useMask();
            end
            if contains(Mode, 'LTA')% || strcmpi(Mode, 'LTA-EMG') || strcmpi(Mode, 'LTA-&-EMG')  || strcmpi(Mode, 'LTA-tdt') ||  strcmpi(Mode, 'LTA-&-tdt')  || strcmpi(Mode, 'LTA-&-EMG-&-tdt')
                early = obj.LTA.early;
                rews = obj.LTA.rews;
                delta_lick_time = obj.LTA.delta_lick_time;
                lick_time_next_trial = obj.LTA.lick_time_next_trial;
                log_lick_time_next_trial = obj.LTA.log_lick_time_next_trial;
                RPEwin_xshift = obj.LTA.RPEwin_xshift;
                RPEwin = obj.LTA.RPEwin;
                if stimOnly
                    % early(ismember(early, obj.LTA.nostimIdx)) = [];
                    % rews(ismember(rews, obj.LTA.nostimIdx)) = [];
                    delta_lick_time(obj.LTA.nostimIdx) = nan;
                    lick_time_next_trial(obj.LTA.nostimIdx) = nan;
                    log_lick_time_next_trial(obj.LTA.nostimIdx) = nan;
                end
                
                if strcmpi(Mode, 'LTA-EMG')
                    if normalizeX
                        medians = obj.normSig(obj.LTA.EMG.medians);
                        means = obj.normSig(obj.LTA.EMG.means);
                        RPE = obj.normSig(obj.LTA.EMG.RPE);
                    else
                        medians = obj.LTA.EMG.medians;
                        means = obj.LTA.EMG.means;
                        RPE = obj.LTA.EMG.RPE;
                    end
                    xxl = ['EMG, Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's post-lick'];
                    % Theta_Names = {'b0', ['EMG' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};
                elseif strcmpi(Mode, 'LTA-tdt')
                    if normalizeX
                        medians = obj.normSig(obj.LTA.tdt.medians);
                        means = obj.normSig(obj.LTA.tdt.means);
                        RPE = obj.normSig(obj.LTA.tdt.RPE);
                    else
                        medians = obj.LTA.tdt.medians;
                        means = obj.LTA.tdt.means;
                        RPE = obj.LTA.tdt.RPE;
                    end
                    xxl = ['tdt, Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's post-lick'];
                    % Theta_Names = {'b0', ['tdt' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};
                elseif strcmpi(Mode, 'LTA-X')
                    if normalizeX
                        medians = obj.normSig(obj.LTA.X.medians);
                        means = obj.normSig(obj.LTA.X.means);
                        RPE = obj.normSig(obj.LTA.X.RPE);
                    else
                        medians = obj.LTA.X.medians;
                        means = obj.LTA.X.means;
                        RPE = obj.LTA.X.RPE;
                    end
                    xxl = ['X, Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's post-lick'];
                    % Theta_Names = {'b0', ['X' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};
                else % if ~strcmpi(Mode, 'LTA-EMG') &&%strcmpi(Mode, 'LTA') || strcmpi(Mode, 'LTA-&-EMG') || strcmpi(Mode, 'LTA-&-tdt') || strcmpi(Mode, 'LTA-&-EMG-&-tdt')
                    if normalizeX
                        medians = obj.normSig(obj.LTA.medians);
                        means = obj.normSig(obj.LTA.means);
                        RPE = obj.normSig(obj.LTA.RPE);
                    else
                        medians = obj.LTA.medians;
                        means = obj.LTA.means;
                        RPE = obj.LTA.RPE;
                    end
                    xxl = ['DA, Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's post-lick'];
                    % if strcmpi(Mode, 'LTA'), Theta_Names = {'b0', ['DA' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};,
                    % elseif strcmpi(Mode, 'LTA-&-EMG'), Theta_Names = {'b0', 'EMG', ['DA' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};,
                    % elseif strcmpi(Mode, 'LTA-&-tdt'), Theta_Names = {'b0', 'tdt', ['DA' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};,
                    % elseif strcmpi(Mode, 'LTA-&-EMG-&-tdt'), Theta_Names = {'b0', 'EMG', 'tdt', ['DA' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};,
                    % end
                end
            elseif contains(Mode, 'LOTA') %|| strcmpi(Mode, 'LOTA-EMG') || strcmpi(Mode, 'LOTA-&-EMG')  || strcmpi(Mode, 'LOTA-tdt') ||  strcmpi(Mode, 'LOTA-&-tdt')  || strcmpi(Mode, 'LOTA-&-EMG-&-tdt')
                early = obj.LOTA.early;
                rews = obj.LOTA.rews;
                delta_lick_time = obj.LOTA.delta_lick_time;
                lick_time_next_trial = obj.LOTA.lick_time_next_trial;
                log_lick_time_next_trial = obj.LOTA.log_lick_time_next_trial;
                RPEwin_xshift = obj.LOTA.RPEwin_xshift;
                RPEwin = obj.LOTA.RPEwin;
                if strcmpi(Mode, 'LOTA-EMG')
                    if normalizeX
                        medians = obj.normSig(obj.LOTA.EMG.medians);
                        means = obj.normSig(obj.LOTA.EMG.means);
                        RPE = obj.normSig(obj.LOTA.EMG.RPE);
                    else
                        medians = obj.LOTA.EMG.medians;
                        means = obj.LOTA.EMG.means;
                        RPE = obj.LOTA.EMG.RPE;
                    end
                    xxl = ['pre-LOI EMG, Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'];
                    % Theta_Names = {'b0', ['EMG' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};
                elseif strcmpi(Mode, 'LOTA-tdt')
                    if normalizeX
                        medians = obj.normSig(obj.LOTA.tdt.medians);
                        means = obj.normSig(obj.LOTA.tdt.means);
                        RPE = obj.normSig(obj.LOTA.tdt.RPE);
                    else
                        medians = obj.LOTA.tdt.medians;
                        means = obj.LOTA.tdt.means;
                        RPE = obj.LOTA.tdt.RPE;
                    end
                    xxl = ['pre-LOI tdt, Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'];
                    % Theta_Names = {'b0', ['tdt' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};
                elseif strcmpi(Mode, 'LOTA-X')
                    if normalizeX
                        medians = obj.normSig(obj.LOTA.X.medians);
                        means = obj.normSig(obj.LOTA.X.means);
                        RPE = obj.normSig(obj.LOTA.X.RPE);
                    else
                        medians = obj.LOTA.X.medians;
                        means = obj.LOTA.X.means;
                        RPE = obj.LOTA.X.RPE;
                    end
                    xxl = ['pre-LOI X, Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'];
                    % Theta_Names = {'b0', ['X' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};
                else %if strcmpi(Mode, 'LOTA') || strcmpi(Mode, 'LOTA-&-EMG') || strcmpi(Mode, 'LOTA-&-tdt')  || strcmpi(Mode, 'LOTA-&-EMG-&-tdt')
                    if normalizeX
                        medians = obj.normSig(obj.LOTA.medians);
                        means = obj.normSig(obj.LOTA.means);
                        RPE = obj.normSig(obj.LOTA.RPE);
                    else
                        medians = obj.LOTA.medians;
                        means = obj.LOTA.means;
                        RPE = obj.LOTA.RPE;
                    end
                    xxl = ['pre-LOI DA, Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's wrt LO'];
                    % if strcmpi(Mode, 'LOTA'), Theta_Names = {'b0', ['DA' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};,
                    % elseif strcmpi(Mode, 'LOTA-&-EMG'), Theta_Names = {'b0', 'EMG', ['DA' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};,
                    % elseif strcmpi(Mode, 'LOTA-&-tdt'), Theta_Names = {'b0', 'tdt', ['DA' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};,
                    % elseif strcmpi(Mode, 'LOTA-&-EMG-&-tdt'), Theta_Names = {'b0', 'EMG', 'tdt', ['DA' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's']};,
                    % end
                end

            elseif contains(Mode, 'CTA')
                CTA_fithelper_runmodelsandplot


            elseif contains(Mode, 'outcome')
                if normalizeX
                    medians = obj.normSig(obj.LTA.medians);
                    means = obj.normSig(obj.LTA.means);
                    RPE = obj.normSig(obj.LTA.RPE);
                else
                    medians = obj.LTA.medians;
                    means = obj.LTA.means;
                    RPE = obj.LTA.RPE;
                end
                xxl = ['outcome'];
                early = obj.LTA.early;
                rews = obj.LTA.rews;
                delta_lick_time = obj.LTA.delta_lick_time;
                lick_time_next_trial = obj.LTA.lick_time_next_trial;
                log_lick_time_next_trial = obj.LTA.log_lick_time_next_trial;
                RPEwin_xshift = obj.LTA.RPEwin_xshift;
                RPEwin = obj.LTA.RPEwin;

            
            else, error('Mode is LTA or LOTA or CTA')
            end
            if stimOnly
                medians(obj.LTA.nostimIdx) = nan;
                means(obj.LTA.nostimIdx) = nan;
                RPE(obj.LTA.nostimIdx) = nan;
            end
            Theta_Names = obj.getThetaNames(Mode, RPEwin_xshift, RPEwin);
            mdls = cell(5,1);
            
            [f,ax] = makeStandardFigure(10,[2,5]);
            % predict n+1 lick time, as in eLife paper
            [~,~,STATS, yfit, rsq, ~,ModelPacket,~,y, ~,excl] = obj.fitModel(Mode, 'abs', 'med',normalizeX,Early_or_Rew_conditioning, stimOnly);
            mdls{1} = ModelPacket.mdl;
            x=medians;
            x(excl) = nan;
            if normalizeX, x = obj.normSig(x);end
            % y=lick_time_next_trial;
            Title='Predict lick time, n';
            Xl = ['Median ', xxl];
            Yl='lick time, n';
            obj.plotModel(x,y,yfit,early,rews,STATS,rsq,Title,Xl,Yl, ax(1));
            obj.plotCoeff(ModelPacket,Theta_Names,[],'beta', ax(6));
            
            [~,~,STATS, yfit, rsq, ~,ModelPacket,~,y, ~, excl] = obj.fitModel(Mode, 'logabs', 'med',normalizeX,Early_or_Rew_conditioning, stimOnly);
            mdls{2} = ModelPacket.mdl;
            x=medians;
            x(excl) = nan;
            if normalizeX, x = obj.normSig(x);end
            % y=log_lick_time_next_trial;
            Title='LOG lick time, n';
            Xl = ['Median ', xxl];
            Yl='LOG lick time, n';
            obj.plotModel(x,y,yfit,early,rews,STATS,rsq,Title,Xl,Yl, ax(2));
            obj.plotCoeff(ModelPacket,Theta_Names,[],'beta', ax(7));

            [~,~,STATS, yfit, rsq, ~,ModelPacket,~,y, ~, excl] = obj.fitModel(Mode, 'del', 'rails',normalizeX,Early_or_Rew_conditioning, stimOnly);
            mdls{3} = ModelPacket.mdl;
            x=RPE;
            x(excl) = nan;
            if normalizeX, x = obj.normSig(x);end
            % y=delta_lick_time;
            Title='Delta-n vs Rails';
            Xl = ['Rails ', xxl];
            Yl='lt (n+1) - n';
            obj.plotModel(x,y,yfit,early,rews,STATS,rsq,Title,Xl,Yl, ax(3));
            obj.plotCoeff(ModelPacket,Theta_Names,[],'beta', ax(8));
            
            [~,~,STATS, yfit, rsq, ~,ModelPacket,~,y, ~,excl] = obj.fitModel(Mode, 'del', 'mean',normalizeX,Early_or_Rew_conditioning, stimOnly);
            mdls{4} = ModelPacket.mdl;
            x=means;
            x(excl) = nan;
            if normalizeX, x = obj.normSig(x);end
            % y=delta_lick_time;
            Title='Delta-n vs Mean DA';
            Xl = ['Mean DA ', xxl];
            Yl='lt (n+1) - n';
            obj.plotModel(x,y,yfit,early,rews,STATS,rsq,Title,Xl,Yl, ax(4));
            obj.plotCoeff(ModelPacket,Theta_Names,[],'beta', ax(9));
            
            [~,~,STATS, yfit, rsq, ~,ModelPacket,~,y, ~,excl] = obj.fitModel(Mode, 'del', 'med',normalizeX,Early_or_Rew_conditioning, stimOnly);
            mdls{5} = ModelPacket.mdl;
            x=medians;
            x(excl) = nan;
            if normalizeX, x = obj.normSig(x);end
            % y=delta_lick_time;
            Title='Delta-n vs Mean DA';
            Xl = ['Median DA ', xxl];
            Yl='lt (n+1) - n';
            obj.plotModel(x,y,yfit,early,rews,STATS,rsq,Title,Xl,Yl, ax(5));
            obj.plotCoeff(ModelPacket,Theta_Names,[],'beta', ax(10));
            
            Name = [obj.iv.sessionCode, ' ' Mode, ' fits, Window: ' num2str(RPEwin_xshift/1000) ':' num2str((RPEwin_xshift+RPEwin)/1000) 's ' Early_or_Rew_conditioning];
            if iscell(Name), Name=cell2mat(Name);end
            set(f, 'name', Name); 
        end
        function [X,y, f1, f2, mdls, ModelDeets, Name] = runNestedModel(obj,Mode,div,Model,Signal, useMask, Early_or_Rew_conditioning)
            %
            %   We will divide the post-lick (LTA) or pre-LOI (LOTA) interval by the number of divisions here and fit models for each
            %
            normalizeX = true;
            if nargin < 3, div=10; end
            if nargin < 4, Model='del';end
            if nargin < 5, Signal = 'Mean'; end
            if nargin < 6, useMask = false;end % this has to do with limiting our conideration only to those trials that are between 0-7s, so not considering ITI
            if nargin < 7, Early_or_Rew_conditioning = 'none';end % if this is 'early' or 'reward', we will only 
                %                                           predict on that category on the current trial. this is mostly for the del model
            if useMask, obj.useMask; end

            Models = {};
            mdls = cell(div,1);
            ModelDeets = cell(div,1);
            rsq = [];
            yfit = {};
            STATS={};

            [f1, ax1]=makeStandardFigure(div, [2, round(div/2)]);
            [f2, ax2]=makeStandardFigure(div, [2, round(div/2)]);
            set(f1,  'units', 'normalized', 'Position', [0 1 1 0.6])
            set(f2, 'units', 'normalized', 'Position', [0 0 1 0.4])
            
            if contains(Mode, 'LTA') %|| strcmpi(Mode, 'LTA-&-EMG') || strcmpi(Mode, 'LTA-&-tdt') || strcmpi(Mode, 'LTA-&-EMG-&-tdt')
                if strcmpi(Model, 'del')
                    y=obj.LTA.delta_lick_time;
                    Yl='lt (n+1) - n';
                elseif strcmpi(Model, 'abs')
                    y=obj.LTA.lick_time_next_trial;
                    Yl='lick time (n+1)';
                elseif strcmpi(Model, 'shuffled_del')
                    y=obj.LTA.shuffled_delta_lick_time;
                    Yl='shuffled lt (n+1) - n';
                elseif strcmpi(Model, 'shuffled_abs')
                    y=obj.LTA.shuffled_lick_time_next_trial;
                    Yl='shuffled lick time (n+1)';
                elseif strcmpi(Model, 'logabs')
                    y=obj.LTA.log_lick_time_next_trial;
                    Yl='LOG lt (n+1)';
                end

                xshift = linspace(0,10000,div+1);
                Window = 10000/div;
                early = obj.LTA.early;
                rews = obj.LTA.rews;
                X = {};
                for idiv = 1:div
                    % reset LTA
                    obj.resetLTA(xshift(idiv), Window);
                    if useMask, obj.useMask; end
                    if strcmpi(Signal, 'Mean')
                        x = (obj.LTA.means - min(obj.LTA.means))/(max(obj.LTA.means)-min(obj.LTA.means));
                        Xl = ['Mean DA'];
                    elseif strcmpi(Signal, 'Median')
                        x = (obj.LTA.medians - min(obj.LTA.medians))/(max(obj.LTA.medians)-min(obj.LTA.medians));
                        Xl = ['Median DA'];
                    elseif strcmpi(Signal, 'Rails')
                        x = obj.LTA.RPE;
                        Xl = ['Rails DA'];
                    end
                    % if we are doing some kind of early or reward conditioning, we need to now mask x to only predict on the desired trial category
                    if strcmpi(Early_or_Rew_conditioning, 'early')
                        % predict on only the early trials for the current trial
                        y(obj.LTA.lick_time >= 3.333) = nan;
                    elseif strcmpi(Early_or_Rew_conditioning, 'reward')
                        % predict on only the rewarded trials for the current trial
                        y(obj.LTA.lick_time < 3.333 | obj.LTA.lick_time > 7) = nan;
                    elseif  ~strcmpi(Early_or_Rew_conditioning, 'none')
                        error('Early_or_Rew_conditioning can only be none, early or reward')
                    end


                    % run the model [B,DEV,STATS, yfit, rsq, resid,ModelPacket, Signal,y, mdl]
                    [~,~,STATS{idiv}, yfit{idiv}, rsq(idiv),~,Models{idiv},X{idiv}] = obj.fitModel(Mode, Model, Signal, normalizeX, Early_or_Rew_conditioning);
                    % retrieve the mdl from fitglm from modelpacket, so we can pass this to collating runner
                    mdls{idiv} = Models{idiv}.mdl;
                    ModelDeets{idiv} = Models{idiv}.ModelDeets;
                    Theta_Names = obj.getThetaNames(Mode, xshift(idiv), Window);
                    WindowText = [num2str(xshift(idiv)/1000) ':' num2str((xshift(idiv)+Window)/1000) 's'];
                    
                    Title=[Signal, ' ' WindowText ' post-lick'];
                    
                    obj.plotModel(x,y,yfit{idiv},early,rews,STATS{idiv},rsq(idiv),Title,Xl,Yl, ax1(idiv));
                    obj.plotCoeff(Models{idiv},Theta_Names,[],[Mode ' ' WindowText], ax2(idiv));
                    hleg = findobj(f2,'Type','legend');
                    set(hleg, 'Visible','off');
                end
            elseif contains(Mode, 'LOTA') %|| strcmpi(Mode, 'LOTA-&-EMG') || strcmpi(Mode, 'LOTA-&-tdt') || strcmpi(Mode, 'LOTA-&-EMG-&-tdt')
                if strcmpi(Model, 'del')
                    y=obj.LOTA.delta_lick_time;
                    Yl='lt (n+1) - n';
                elseif strcmpi(Model, 'abs')
                    y=obj.LOTA.lick_time_next_trial;
                    Yl='lick time (n+1)';
                elseif strcmpi(Model, 'shuffled_del')
                    y=obj.LOTA.shuffled_delta_lick_time;
                    Yl='shuffled lt (n+1) - n';
                elseif strcmpi(Model, 'shuffled_abs')
                    y=obj.LOTA.shuffled_lick_time_next_trial;
                    Yl='shuffled lick time (n+1)';
                elseif strcmpi(Model, 'logabs')
                    y=obj.LOTA.log_lick_time_next_trial;
                    Yl='LOG lt (n+1)';
                end

                xshift = linspace(-10000,0,div+1);
                Window = 10000/div;
                Models = {};

                early = obj.LOTA.early;
                rews = obj.LOTA.rews;
                X = {};
                for idiv = 1:div
                    % reset LOTA
                    obj.resetLOTA(xshift(idiv), Window);
                    if useMask, obj.useMask;end
                    if strcmpi(Signal, 'Mean')
                        x = (obj.LOTA.means - min(obj.LOTA.means))/(max(obj.LOTA.means)-min(obj.LOTA.means));
                        Xl = 'Mean DA';
                    elseif strcmpi(Signal, 'Medians')
                        x = (obj.LOTA.medians - min(obj.LOTA.medians))/(max(obj.LOTA.medians)-min(obj.LOTA.medians));
                        Xl = 'Median DA';
                    elseif strcmpi(Signal, 'Rails')
                        x = obj.LOTA.RPE;
                        Xl = 'Rails DA';
                    end
                     % if we are doing some kind of early or reward conditioning, we need to now mask x to only predict on the desired trial category
                     % however, this would need to look at the previous trial...it really doesn''t make sense for LOTA so not implemented
                    if strcmpi(Early_or_Rew_conditioning, 'early')
                        error('not implemented for LOTA')
                    elseif strcmpi(Early_or_Rew_conditioning, 'reward')
                        error('not implemented for LTA')
                    elseif  ~strcmpi(Early_or_Rew_conditioning, 'none')
                        error('Early_or_Rew_conditioning can only be none, early or reward')
                    end
                    % run the model
                    [~,~,STATS{idiv}, yfit{idiv}, rsq(idiv),~,Models{idiv},X{idiv}] = obj.fitModel(Mode, Model, Signal, normalizeX, Early_or_Rew_conditioning);
                    % retrieve the mdl from fitglm from modelpacket, so we can pass this to collating runner
                    mdls{idiv} = Models{idiv}.mdl;
                    ModelDeets{idiv} = Models{idiv}.ModelDeets;
                    Theta_Names = obj.getThetaNames(Mode, xshift(idiv), Window);
                    WindowText = [num2str(xshift(idiv)/1000) ':' num2str((xshift(idiv)+Window)/1000) 's'];
                    
                    Title=[Signal, ' ' WindowText ' pre-LO'];
                    
                    obj.plotModel(x,y,yfit{idiv},early,rews,STATS{idiv},rsq(idiv),Title,Xl,Yl, ax1(idiv));
                    obj.plotCoeff(Models{idiv},Theta_Names,[],[Mode ' ' WindowText], ax2(idiv));
                    hleg = findobj(f2,'Type','legend');
                    set(hleg, 'Visible','off');
                end
            end
            Name = [obj.iv.sessionCode, ' ' Mode];
            if iscell(Name), Name = cell2mat(Name);end
            set(f1, 'name', Name)
            set(f2, 'name', Name)
        end
        function runNestedByTimeModel(obj,Mode,div,Model,Signal,Forward)
            % start by getting each division of time by itself.
            % This will extract the predictor set
            if nargin<6
                if contains(Mode, 'LTA'), Forward = false; else, Forward=true;end 
            end
            [X,y] = runNestedModel(obj,Mode,div,Model,Signal);
            %
            % Now run the model again nesting in times
            %
            obj.analysis.NestedTime = [];            
            
            early = obj.LTA.early;
            rews = obj.LTA.rews;
            Xl = Signal;
            Yl = Model;
            [f1, ax1]=makeStandardFigure(div, [2, round(div/2)]);
            [f2, ax2]=makeStandardFigure(div, [2, round(div/2)]);
            if ~Forward
                Order = fliplr(1:numel(X));
                obj.analysis.NestedTime(numel(X)).Theta_Names = obj.getThetaNames(Mode, (numel(X)-1)*10000/div, 10000/div);
            elseif Forward
                Order = 1:numel(X);
                obj.analysis.NestedTime(1).Theta_Names = obj.getThetaNames(Mode, -10000, 10000/div);
            end
            for ii = Order
                if ~Forward
                    Xd = cell2mat(X(ii:numel(X)));
                elseif Forward
                    Xd = cell2mat(X(1:ii));
                end
                warning('you shouldn''t use this glmfit method for rails signal, it inflates the rsq. see note within fitmodel from 6-13-23. this method should be updated to a fitglm method')
                [B,DEV,STATS] = glmfit(Xd, y, 'normal');
                yfit = [ones(size(Xd,1),1),Xd]*STATS.beta;
                [rsq,resid] = rSquared(y,yfit);
                obj.analysis.NestedTime(ii).Model = Model;
                obj.analysis.NestedTime(ii).Signal = Signal;
                obj.analysis.NestedTime(ii).div = ii;
                obj.analysis.NestedTime(ii).p = STATS.p;
                obj.analysis.NestedTime(ii).B = B;
                obj.analysis.NestedTime(ii).DEV = DEV;
                obj.analysis.NestedTime(ii).STATS = STATS;
                obj.analysis.NestedTime(ii).yfit = yfit;
                obj.analysis.NestedTime(ii).rsq = rsq;
                obj.analysis.NestedTime(ii).resid = resid;
                if ~Forward && ii ~= numel(X)
                    obj.analysis.NestedTime(ii).Theta_Names = [obj.getThetaNames(Mode, (ii-1)*10000/div, 10000/div), obj.analysis.NestedTime(ii+1).Theta_Names(2:end)];
                elseif Forward && ii ~=1
                    obj.analysis.NestedTime(ii).Theta_Names = [obj.analysis.NestedTime(ii-1).Theta_Names, obj.getThetaNames(Mode, -10000 + (10000/div)*(ii-1), 10000/div, true)];
                end
                
                Theta_Names = obj.analysis.NestedTime(ii).Theta_Names;
                if ~Forward
                    WindowText = [num2str((ii-1)*10000/div/1000) ':' num2str(((ii-1)*10000/div+10000/div)/1000) 's'];
                elseif Forward
                    WindowText = [num2str(-10) ':' num2str(-10 + (ii)*10/div) 's'];
                end

                Title=[Mode, ' ', Model, ' ' Signal ' ' WindowText]; 

                obj.plotModel(Xd,y,yfit,early,rews,obj.analysis.NestedTime(ii).STATS,obj.analysis.NestedTime(ii).rsq,Title,Xl,Yl, ax1(ii));
                obj.plotCoeff([obj.analysis.NestedTime(ii)],Theta_Names,[],[Mode ' ' WindowText], ax2(ii));
                hleg = findobj(f2,'Type','legend');
                set(hleg, 'Visible','off');
            end
        end
        function [rsq, criterion, ModelNames, Theta_Names, mdls, fs] = runSelectModelByDivs(obj,Mode,div,Model,Signal)
            if strcmpi(Mode,'LTA')
                xshift = linspace(0,10000,div+1);
            elseif strcmpi(Mode,'LOTA')
                xshift = linspace(-10000,0,div+1);
            end
            Window = 10000/div;
            for ii = 1:numel(xshift)
                % run the select model for this window
                [rsq{ii}, criterion{ii}, ModelNames, Theta_Names{ii}, mdls, fs(ii)] = obj.SelectModel(Mode,xshift(ii),Window,Model,Signal);
            end
        end
        function [rsq, criterion, ModelNames, Theta_Names, mdls, f] = SelectModel(obj,Mode,xshift,Window,Model,Signal)
            % 
            %   Here, Mode is just LTA or LOTA. We will try all permutations of the model to pick the one with lowest AIC
            % 
            %   Model: del, abs, logabs
            %   Signal: rails, mean, medians
            %            
            normalizeX = true;
            % check for signals...
            if strcmpi(Mode, 'LTA') 
                obj.resetLTA(xshift, Window);
                early = obj.LTA.early;
                rews = obj.LTA.rews;
                WindowText = [num2str(xshift/1000) ':' num2str((xshift+Window)/1000)];
                xxl = ['Window: ', WindowText, 's post-lick'];
                Title=[Signal, ' ', WindowText, ' post-lick'];
            elseif strcmpi(Mode, 'LOTA')
                obj.resetLOTA(xshift, Window);
                early = obj.LOTA.early;
                rews = obj.LOTA.rews;
                WindowText = [num2str(xshift/1000) ':' num2str((xshift+Window)/1000)];
                xxl = ['pre-LOI, Window: ' WindowText 's wrt LO'];
                Title=[Signal, ' ' WindowText ' pre-LO'];
            else 
                error('Mode is LTA or LOTA')
            end

            if strcmpi(Model, 'del')
                Yl='lt (n+1) - n';
            elseif strcmpi(Model, 'abs')
                Yl='lick time (n+1)';
            elseif strcmpi(Model, 'logabs')
                Yl='LOG lt (n+1)';
            end
            if strcmpi(Signal, 'Mean')
                Xl = 'Mean DA';
            elseif strcmpi(Signal, 'Medians')
                Xl = 'Median DA';
            elseif strcmpi(Signal, 'Rails')
                Xl = 'Rails DA';
            end
            
            
            ModelNames = {''}; 
            if isfield(obj.LTA,'EMG')
                % disp('detected EMG')
                ModelNames{end+1} = {'-EMG'};
                ModelNames{end+1} = {'-&-EMG'};
            end
            if isfield(obj.LTA,'X')
                % disp('detected X')
                ModelNames{end+1} = {'-X'};
                ModelNames{end+1} = {'-&-X'};
                if isfield(obj.LTA, 'EMG')
                    ModelNames{end+1} = {'-X-EMG'};
                    ModelNames{end+1} = {'-&-EMG-&-X'};
                end
            end 
            if isfield(obj.LTA,'tdt')
                % disp('detected tdt')
                ModelNames{end+1} = {'-tdt'};
                ModelNames{end+1} = {'-&-tdt'};
                if isfield(obj.LTA,'EMG') 
                    ModelNames{end+1} = {'-EMG-tdt'};
                    ModelNames{end+1} = {'-&-EMG-&-tdt'};
                    if isfield(obj.LTA,'X')
                        ModelNames{end+1} = {'-X-EMG-tdt'};
                        ModelNames{end+1} = {'-&-EMG-&-X-&-tdt'};
                    end
                elseif isfield(obj.LTA,'X')
                    ModelNames{end+1} = {'-X-tdt'}; 
                    ModelNames{end+1} = {'-&-X-&-tdt'}; 
                end
            end 
            ModelNames = cellfun(@(x) strcat(Mode, x), ModelNames, 'uniformoutput',0)';

            for ii = 1:numel(ModelNames)
                [~,~,STATS{ii}, yfit{ii}, rsq(ii),~,Models{ii},X{ii}, y{ii}] = obj.fitModel(ModelNames{ii}, Model, Signal, normalizeX);
                Theta_Names{ii} = obj.getThetaNames(ModelNames{ii}, xshift, Window);
                WindowText = [num2str(xshift/1000) ':' num2str((xshift+Window)/1000) 's'];
            
%               

                Theta_Names_short = cellfun(@(x) x{1}, cellfun(@(x) strsplit(x,' '), Theta_Names{ii}, 'uniformoutput', 0), 'uniformoutput', 0);
            
                %debug
                t = table(y{ii}, ones(numel(X{1}),1), 'VariableNames', {Signal, Theta_Names_short{1}});
                for iii = 1:numel(Theta_Names_short(2:end))
                    name = Theta_Names_short(1+iii);
                    t = addvars(t,X{ii}(:,iii), 'NewVariableNames', name);
                end

%                 if numel(Theta_Names_short) <= 2
%                     modelspec = ['y~' Theta_Names_short{2}];
%                 else
                modelspec = cell2mat([Signal,'~',Theta_Names_short{1}, cellfun(@(x) ['+',x],Theta_Names_short(2:end), 'uniformoutput',0)]);
%                 end
                mdl = fitglm(t,modelspec,'Distribution','normal','intercept',false);
                XXnew.B = mdl.Coefficients.Estimate;
                XXnew.STATS.se = mdl.Coefficients.SE;
                XXnew.STATS.dfe = mdl.DFE;

                if ii == numel(ModelNames)
%                     [f,ax] = makeStandardFigure(4, [2,2]);
                    [f,ax] = makeStandardFigure(4, [2,2]);
%                     obj.plotModel(X{1},y{ii},yfit{ii},early,rews,STATS{ii},rsq(ii),Title,Xl,Yl, ax(1));
%                     obj.plotCoeff(Models{ii},Theta_Names,[],[Mode ' ' WindowText], ax(3));
                    % obj,x,y,yfit,early, rews,STATS,rsq,Title,Xl, Yl, ax)
                    obj.plotModel(mdl.Variables{:,end},mdl.Variables.mean,mdl.Fitted.Response,early,rews,STATS{ii},mdl.Rsquared.Ordinary,[Title ' - NEW METHOD'],Xl,Yl, ax(2));
                    obj.plotCoeff(XXnew,Theta_Names{ii},[],[Mode ' ' WindowText], ax(4));
                    set(f, 'name', [cell2mat(obj.iv.sessionCode), ' ' cell2mat(ModelNames{ii}) ' ' WindowText])
                end

                AIC(ii) = mdl.ModelCriterion.AIC;
                AICc(ii) = mdl.ModelCriterion.AICc;
                CAIC(ii) = mdl.ModelCriterion.CAIC;
                BIC(ii) = mdl.ModelCriterion.BIC;
                rsq_corrected(ii) = mdl.Rsquared.Ordinary;
                mdls{ii} = mdl;
                
            end
%             [f,ax] = makeStandardFigure(2, [1,2]);
            plot(ax(1), 1:numel(AIC), AIC, 'k-', 'linewidth', 2,'displayname','AIC')
            plot(ax(1), 1:numel(AICc), AICc, 'b-', 'linewidth', 2,'displayname','AICc')
            plot(ax(1), 1:numel(CAIC), CAIC, 'r-', 'linewidth', 2,'displayname','CAIC')
            plot(ax(1), 1:numel(BIC), BIC, 'g-','linewidth', 2, 'displayname','BIC')
            ylabel(ax(1),'value')
            xticks(ax(1),1:numel(AIC))
%             xticklabels(ModelNames)
            plot(ax(1),find(AIC==min(AIC)), min(AIC), 'k*','linewidth', 2,'displayname','best')
            plot(ax(1),find(AICc==min(AICc)), min(AICc), 'b*','linewidth', 2,'displayname','best')
            plot(ax(1),find(CAIC==min(CAIC)), min(CAIC), 'r*','linewidth', 2,'displayname','best')
            plot(ax(1),find(BIC==min(BIC)), min(BIC), 'g*','linewidth', 2,'displayname','best')
            legend(ax(1), 'show')

            plot(ax(3), 1:numel(AIC), rsq_corrected, 'k-', 'linewidth', 2,'displayname','Rsq fitglm')
            ylabel(ax(3),'Rsq')
            xticks(ax(3),1:numel(AIC))
            % cellfun(@(x) disp(x),ModelNames, 'uniformoutput',0)
            
            criterion.AIC = AIC;
            criterion.AICc = AICc;
            criterion.CAIC = CAIC;
            criterion.BIC = BIC;
            rsq = rsq_corrected;
        end
        function Theta_Names = getThetaNames(obj, Mode, xshift, win, noBeta)
            if nargin < 5, noBeta = false; end
            WindowText = [num2str(xshift/1000) ':' num2str((xshift+win)/1000) 's'];
            thetanames_sloshingModel % call the helper script
            if noBeta, Theta_Names = Theta_Names(2:end); end
        end
        function Extract_LOI_predictors(obj, sObj)
            obj.analysis.LOI.note = '-400:-1 ms from cue event included in mean and median';
            lampOff = sObj.getXPositionsWRTgfit(sObj.GLM.lampOff_s);
            cue = sObj.getXPositionsWRTgfit(sObj.GLM.cue_s);
            sObj.GLM.LOI_s = sObj.GLM.cue_s - sObj.GLM.lampOff_s;
            % let's get all the LOI predictors
            % and then re-align the LOI to the trial indicies from single-trial binning
            LOI_ts = {};
            for ii = 1:numel(sObj.GLM.pos.cue)
                LOI_gfit{ii} = sObj.GLM.gfit(lampOff(ii) : cue(ii));
                if isfield(sObj.GLM, 'tdt')
                    LOI_tdt{ii} = sObj.GLM.tdt(lampOff(ii) : cue(ii));
                end
                if isfield(sObj.GLM, 'gX')
                    gX = sObj.GLM.gX(1:2:end);
                    LOI_X{ii} = gX(lampOff(ii) : cue(ii));
                end
                if isfield(sObj.GLM, 'EMG')
                    EMG = sObj.GLM.EMG(1:2:end);
                    LOI_EMG{ii} = EMG(lampOff(ii) : cue(ii));
                end
            end
            LOI_gfit = LOI_gfit(cell2mat(sObj.ts.BinParams.trials_in_each_bin));
            obj.analysis.LOI.gfit_mean = cell2mat(cellfun(@(x) mean(x(end-400:end-1)), LOI_gfit, 'uniformoutput', 0))';
            obj.analysis.LOI.gfit_median = cell2mat(cellfun(@(x) median(x(end-400:end-1)), LOI_gfit, 'uniformoutput', 0))';
            obj.analysis.LOI.LOI_gfit = LOI_gfit;
            if isfield(sObj.GLM, 'tdt')
                LOI_tdt = LOI_tdt(cell2mat(sObj.ts.BinParams.trials_in_each_bin));
                obj.analysis.LOI.tdt_mean = cell2mat(cellfun(@(x) mean(x(end-400:end-1)), LOI_tdt, 'uniformoutput', 0))';
                obj.analysis.LOI.tdt_median = cell2mat(cellfun(@(x) median(x(end-400:end-1)), LOI_tdt, 'uniformoutput', 0))';
                obj.analysis.LOI.LOI_tdt = LOI_tdt;
            end
            if isfield(sObj.GLM, 'gX')
                LOI_X = LOI_X(cell2mat(sObj.ts.BinParams.trials_in_each_bin));
                obj.analysis.LOI.X_mean = cell2mat(cellfun(@(x) mean(x(end-400:end-1)), LOI_X, 'uniformoutput', 0))';
                obj.analysis.LOI.X_median = cell2mat(cellfun(@(x) median(x(end-400:end-1)), LOI_X, 'uniformoutput', 0))';
                obj.analysis.LOI.LOI_X = LOI_X;
            end
            if isfield(sObj.GLM, 'EMG')
                LOI_EMG = LOI_EMG(cell2mat(sObj.ts.BinParams.trials_in_each_bin));
                obj.analysis.LOI.EMG_mean = cell2mat(cellfun(@(x) mean(x(end-400:end-1)), LOI_EMG, 'uniformoutput', 0))';
                obj.analysis.LOI.EMG_median = cell2mat(cellfun(@(x) median(x(end-400:end-1)), LOI_EMG, 'uniformoutput', 0))';
                obj.analysis.LOI.LOI_EMG = LOI_EMG;
            end 
        end
        function [rsq, criterion, ModelNames, Theta_Names, mdls, fs] = retrospectiveRPE_vs_prospectiveLOI(obj, Model, Signal, xshift, Window, sObj)
            % 
            %   Our predictors will be the RPE signals (1:400), LOI signals (-400,-1) relative to cue and movement ctrls in these windows 
            % 
            %   Model: del, abs, logabs
            %   Signal: mean, medians
            %
            if nargin < 2, Model = 'del'; end
            if nargin < 3, Signal = 'mean'; end
            if nargin < 4, xshift = 0; end
            if nargin < 5, Window = 400; end 
            if nargin > 5, obj.Extract_LOI_predictors(sObj); end
            if ~isfield(obj.analysis, 'LOI'), error('you have to collect LOI info first with Extract_LOI_predictors(obj, sObj)'), end
            normalizeX = true;
            % we stupidly use Signal in 2 ways, so duplicate here
            SignalName = Signal;

            obj.resetLTA(xshift, Window);
            early = obj.LTA.early;
            rews = obj.LTA.rews;
            WindowText = [num2str(xshift/1000) ':' num2str((xshift+Window)/1000)];
            xxl = ['Window: ', WindowText, 's post-lick'];
            Title=[Signal, ' ', WindowText, ' post-lick'];

            ModelName = 'LTA'; 
            LOISignals = [];
            Theta_Names_LOI = {'b0'};
    
            if isfield(obj.LTA,'EMG')
                ModelName = [ModelName, '-&-EMG'];
                Theta_Names_LOI = {Theta_Names_LOI{:}, {'LOIEMG'}};
                if strcmpi(Signal,'mean')
                    LOISignals = [LOISignals, obj.analysis.LOI.EMG_mean];
                elseif strcmpi(Signal,'medians')
                    LOISignals = [LOISignals, obj.analysis.LOI.EMG_median];
                end
            end
            if isfield(obj.LTA,'X')
                ModelName = [ModelName, '-&-X'];
                Theta_Names_LOI = {Theta_Names_LOI{:}, {'LOIX'}};
                if strcmpi(Signal,'mean')
                    LOISignals = [LOISignals, obj.analysis.LOI.X_mean];
                elseif strcmpi(Signal,'medians')
                    LOISignals = [LOISignals, obj.analysis.LOI.X_median];
                end
            end 
            if isfield(obj.LTA,'tdt')
                ModelName = [ModelName, '-&-tdt'];
                Theta_Names_LOI = {Theta_Names_LOI{:}, {'LOItdt'}};
                if strcmpi(Signal,'mean')
                    LOISignals = [LOISignals, obj.analysis.LOI.tdt_mean];
                elseif strcmpi(Signal,'medians')
                    LOISignals = [LOISignals, obj.analysis.LOI.tdt_median];
                end
            end 
            if strcmpi(Signal,'mean')
                LOISignals = [LOISignals, obj.analysis.LOI.gfit_mean];
            elseif strcmpi(Signal,'medians')
                LOISignals = [LOISignals, obj.analysis.LOI.gfit_median];
            else 
                error('shouldn''t get here, check the Signal')
            end

            if normalizeX
                for ii = 1:size(LOISignals,2)
                    LOISignals(:,ii) = obj.normSig(LOISignals(:,ii));
                end
            end
            Theta_Names_LOI = {[Theta_Names_LOI{:}, ['LOIDA -0.4:0.001s wtc']]};
            % this has constructed the LTA model
            Theta_Names{1} = obj.getThetaNames(ModelName, xshift, Window);
            Theta_Names{2} = Theta_Names_LOI{:};
            Theta_Names{3} = {Theta_Names{1}{:}, Theta_Names{2}{2:end}};
            % this calls the helper script where all the model strings are parsed
            Mode = ModelName;
            fitModelHelper_sloshingModel

            % now we need to append the LOI signals
            Signals{1} = Signal;
            Signals{2} = LOISignals;
            Signals{3} = [Signal, LOISignals];

            ModelNames{1} = ModelName;
            xxx = strsplit(ModelName,'LTA');
            ModelNames{2} = ['LOI', xxx{2}];
            ModelNames{3} = [ModelNames{1}, '-&-' ModelNames{2}];
            
            fs = [];
 
            for ii = 1:3 % 3 models
                Theta_Names_short = cellfun(@(x) x{1}, cellfun(@(x) strsplit(x,' '), Theta_Names{ii}, 'uniformoutput', 0), 'uniformoutput', 0);
                t = table(y, ones(numel(Signal(:,1)),1), 'VariableNames', {SignalName, Theta_Names_short{1}});
                for iii = 1:numel(Theta_Names_short(2:end))
                    name = Theta_Names_short(1+iii);
                    t = addvars(t,Signals{ii}(:,iii), 'NewVariableNames', name);
                end

                modelspec = cell2mat([SignalName,'~',Theta_Names_short{1}, cellfun(@(x) ['+',x],Theta_Names_short(2:end), 'uniformoutput',0)]);

                mdl = fitglm(t,modelspec,'Distribution','normal','intercept',false);
                XXnew.B = mdl.Coefficients.Estimate;
                XXnew.STATS.se = mdl.Coefficients.SE;
                XXnew.STATS.dfe = mdl.DFE;
                
                STATS.p = mdl.Coefficients.pValue(end);
                if ii == 1
                    Xl = ['DA, Window: ' num2str(xshift/1000) ':' num2str((xshift+Window)/1000) 's post-lick'];
                else
                    Xl = ['DA, Window: ' num2str((xshift-0.001-Window)/1000) ': -0.001 s pre-cue'];
                end
                Yl = Model;
                if ii == 3
                    [f,ax] = makeStandardFigure(4, [2,2]);
                    obj.plotModel(mdl.Variables{:,end},mdl.Variables.mean,mdl.Fitted.Response,early,rews,STATS,mdl.Rsquared.Ordinary,[Title ' - NEW METHOD'],Xl,Yl, ax(2));
                    obj.plotCoeff(XXnew,Theta_Names{ii},[],[Mode ' ' WindowText], ax(4));
                else
                    [f,ax] = makeStandardFigure(2, [2,1]);
                    obj.plotModel(mdl.Variables{:,end},mdl.Variables.mean,mdl.Fitted.Response,early,rews,STATS,mdl.Rsquared.Ordinary,[Title ' - NEW METHOD'],Xl,Yl, ax(1));
                    obj.plotCoeff(XXnew,Theta_Names{ii},[],[Mode ' ' WindowText], ax(2));
                    hleg = findobj(ax(2),'Type','legend');
                    set(hleg, 'Visible','off');
                end
                set(f, 'name', [cell2mat(obj.iv.sessionCode), ' ' ModelNames{ii} ' ' WindowText])

                fs(end+1) = f;

                AIC(ii) = mdl.ModelCriterion.AIC;
                AICc(ii) = mdl.ModelCriterion.AICc;
                CAIC(ii) = mdl.ModelCriterion.CAIC;
                BIC(ii) = mdl.ModelCriterion.BIC;
                rsq_corrected(ii) = mdl.Rsquared.Ordinary;
                mdls{ii} = mdl;

            end
            plot(ax(1), 1:numel(AIC), AIC, 'k-', 'linewidth', 2,'displayname','AIC')
            plot(ax(1), 1:numel(AICc), AICc, 'b-', 'linewidth', 2,'displayname','AICc')
            plot(ax(1), 1:numel(CAIC), CAIC, 'r-', 'linewidth', 2,'displayname','CAIC')
            plot(ax(1), 1:numel(BIC), BIC, 'g-','linewidth', 2, 'displayname','BIC')
            ylabel(ax(1),'value')
            xticks(ax(1),1:numel(AIC))

            plot(ax(1),find(AIC==min(AIC)), min(AIC), 'k*','linewidth', 2,'displayname','best')
            plot(ax(1),find(AICc==min(AICc)), min(AICc), 'b*','linewidth', 2,'displayname','best')
            plot(ax(1),find(CAIC==min(CAIC)), min(CAIC), 'r*','linewidth', 2,'displayname','best')
            plot(ax(1),find(BIC==min(BIC)), min(BIC), 'g*','linewidth', 2,'displayname','best')
            legend(ax(1), 'show')

            plot(ax(3), 1:numel(AIC), rsq_corrected, 'k-', 'linewidth', 2,'displayname','Rsq fitglm')
            ylabel(ax(3),'Rsq')
            xticks(ax(3),1:numel(AIC))
            
            criterion.AIC = AIC;
            criterion.AICc = AICc;
            criterion.CAIC = CAIC;
            criterion.BIC = BIC;
            rsq = rsq_corrected;
        end
        function reshuffle_lick_time_next_trial(obj, Early_or_Rew_conditioning)
            if nargin < 2
                Early_or_Rew_conditioning = 'none';
            end
            % if we have some kind of conditioning, we need to handle this before shuffling...probably to avoid f'ing us up, we should shuffle each within its category
            lick_time_next_trial = obj.LTA.lick_time_next_trial;
            next_trial = obj.LTA.next_trial;
            lick_time = obj.LTA.lick_time;
            trials_in_each_bin = obj.LTA.trials_in_each_bin;
            % let's start by finding categories
            if strcmpi(Early_or_Rew_conditioning, 'none')
                obj.LTA.shuffled_lick_time_next_trial = lick_time_next_trial(randperm(numel(lick_time_next_trial)));
                obj.LTA.shuffled_lick_time_next_trial(next_trial == obj.iv.num_trials+1) = nan;
                obj.LTA.shuffled_delta_lick_time = obj.LTA.shuffled_lick_time_next_trial - lick_time;

                lick_time_next_trial = obj.LOTA.lick_time_next_trial;
                next_trial = obj.LOTA.next_trial;
                lick_time = obj.LOTA.lick_time;

                obj.LOTA.shuffled_lick_time_next_trial = lick_time_next_trial(randperm(numel(lick_time_next_trial)));
                obj.LOTA.shuffled_lick_time_next_trial(next_trial == obj.iv.num_trials+1) = nan;
                obj.LOTA.shuffled_delta_lick_time = obj.LOTA.shuffled_lick_time_next_trial - lick_time;
            else
                [elligible_trials,inelligible_trials] = obj.get_elligible_trials(Early_or_Rew_conditioning, lick_time, trials_in_each_bin);
                shuffled_lick_time_next_trial = obj.shuffle_elligible_trials(lick_time, inelligible_trials, lick_time_next_trial,elligible_trials);

                obj.LTA.shuffled_lick_time_next_trial = shuffled_lick_time_next_trial;
                obj.LTA.shuffled_lick_time_next_trial(next_trial == obj.iv.num_trials+1) = nan;
                obj.LTA.shuffled_delta_lick_time = obj.LTA.shuffled_lick_time_next_trial - lick_time;
                obj.LTA.inelligible_trials_from_shuffle = inelligible_trials;
                obj.LTA.elligible_trials_from_shuffle = elligible_trials;


                % now for LOTA
                lick_time_next_trial = obj.LOTA.lick_time_next_trial;
                next_trial = obj.LOTA.next_trial;
                lick_time = obj.LOTA.lick_time;
                trials_in_each_bin = obj.LOTA.trials_in_each_bin;

                [elligible_trials,inelligible_trials] = obj.get_elligible_trials(Early_or_Rew_conditioning, lick_time, trials_in_each_bin);
                shuffled_lick_time_next_trial = obj.shuffle_elligible_trials(lick_time, inelligible_trials, lick_time_next_trial,elligible_trials);

                obj.LOTA.shuffled_lick_time_next_trial = shuffled_lick_time_next_trial;
                obj.LOTA.shuffled_lick_time_next_trial(next_trial == obj.iv.num_trials+1) = nan;
                obj.LOTA.shuffled_delta_lick_time = obj.LOTA.shuffled_lick_time_next_trial - lick_time;
                obj.LOTA.inelligible_trials_from_shuffle = inelligible_trials;
                obj.LOTA.elligible_trials_from_shuffle = elligible_trials;
            end
            obj.LTA.shuffle_conditioning = Early_or_Rew_conditioning;
            obj.LOTA.shuffle_conditioning = Early_or_Rew_conditioning;            
        end
        function [elligible_trials,inelligible_trials] = get_elligible_trials(obj, Early_or_Rew_conditioning, lick_time, trials_in_each_bin)
            % for use by shuffle fxn above this
            
            % start with all trials elligible
            elligible_trials = ones(numel(lick_time),1);

            if contains(Early_or_Rew_conditioning, 'Early')
                elligible_trials = find(lick_time <= 3.333);    
            elseif contains(Early_or_Rew_conditioning, 'Reward')
                elligible_trials = find(lick_time >= 3.333 & lick_time <=7.000);
            end

            % knock out ellligible trials if they don't fit the condition
            if contains(Early_or_Rew_conditioning, 'Q')
                % we need to shuffle within the quartiles of trials
                npartitions = 4;
                fLick_trial_num = cell2mat(trials_in_each_bin);
                sorted_trial_num = sort(fLick_trial_num);
                if contains(Early_or_Rew_conditioning, 'Q1')
                    iipart = 1;
                elseif contains(Early_or_Rew_conditioning, 'Q2')
                    iipart = 2;
                elseif contains(Early_or_Rew_conditioning, 'Q3')
                    iipart = 3;
                elseif contains(Early_or_Rew_conditioning, 'Q4')  
                    iipart = 4;   
                else
                    error('must be Q1 Q2 Q3 or Q4 or these -early or -reward')
                end
                if obj.iv.humanMode
                    warning('we are making Q1 beginner, Q2 intermediate, Q3-4 expert trials 1:34')
                    p1Idx = 1+floor(68/npartitions)*(iipart-1);
                    if iipart == npartitions
                        p2Idx = 68;
                    else
                        p2Idx = floor(68/npartitions)*(iipart);
                    end
                else
                    p1Idx = 1+floor(numel(fLick_trial_num)/npartitions)*(iipart-1);
                    if iipart == npartitions
                        p2Idx = numel(fLick_trial_num);
                    else
                        p2Idx = floor(numel(fLick_trial_num)/npartitions)*(iipart);
                    end
                end
                trialsIncluded = sorted_trial_num(p1Idx:p2Idx);
                trialsNotIncluded = ~ismember(fLick_trial_num, trialsIncluded);

                % set to false anything not in included trials
                elligible_trials(trialsNotIncluded) = 0;
            end
            if contains(Early_or_Rew_conditioning, '{')
                % quantiles the original way...first number is which quantile out of how many
                % eg {1,5} -- first out of 5
                % get the quantiles out: 
                fLick_trial_num = cell2mat(trials_in_each_bin);
                sorted_trial_num = sort(fLick_trial_num);
                QQ = strsplit(Early_or_Rew_conditioning, '-');
                QQ(~contains(QQ,'{')) = [];
                QQ = eval(QQ{1});
                [trialsIncluded, trialsNotIncluded] = obj.getQuantilesOfTrials(QQ{1}, QQ{2}, fLick_trial_num,sorted_trial_num);
                elligible_trials(trialsNotIncluded) = 0;
            end            
            inelligible_trials = ~elligible_trials;
            elligible_trials = elligible_trials ==1;
        end
        function shuffled_lick_time_next_trial = shuffle_elligible_trials(obj, lick_time, inelligible_trials, lick_time_next_trial, elligible_trials)
            % for use by the 2 shuffle fxns above this
            lick_time(inelligible_trials) = nan;
            lick_time_next_trial(inelligible_trials) = nan;
            % we then need to only shuffle the elligible trial ids

            elligble_next_trial_lick_times = lick_time_next_trial(elligible_trials);
            shuffled_elligible_lick_time_next_trial = elligble_next_trial_lick_times(randperm(numel(elligble_next_trial_lick_times)));

            shuffled_lick_time_next_trial = nan(size(lick_time));
            shuffled_lick_time_next_trial(elligible_trials) = shuffled_elligible_lick_time_next_trial;
        end
        function plot_DA_vs_delta_t(obj)
            DA = obj.LTA.means;
            del = obj.LTA.delta_lick_time;
            shuffled_del = obj.LTA.shuffled_delta_lick_time;
            early = obj.LTA.early;
            rews = obj.LTA.rews;
            [f,ax] = makeStandardFigure(4,[2,2]);
            plot(ax(1), DA, del, 'k.', 'markersize', 40)
            plot(ax(1), DA(early), del(early), 'r.', 'markersize', 30)
            plot(ax(1), DA(rews), del(rews), 'g.', 'markersize', 30)
            title(ax(1), 'Actual Data')
            ylabel(ax(1), 'delta lick time')
            prettyHxg(ax(3), del(early), 'early trials', 'r', -20:20);
            prettyHxg(ax(3), del(rews), 'rewarded trials', 'g', -20:20);
            xlabel(ax(3), 'delta lick time')

            if ~isfield(obj.LTA,'shuffle_conditioning'), obj.LTA.shuffle_conditioning = 'none';end

            plot(ax(2), DA, shuffled_del, 'k.', 'markersize', 40)
            plot(ax(2), DA(early), shuffled_del(early), 'r.', 'markersize', 30)
            plot(ax(2), DA(rews), shuffled_del(rews), 'g.', 'markersize', 30)
            title(ax(2), sprintf(['Shuffled Lick Time Next Trial\nshuffle-conditioning:' obj.LTA.shuffle_conditioning]))
            ylabel(ax(2), 'shuffled delta lick time')
            xlabel(ax(2),'DA')
            prettyHxg(ax(4), shuffled_del(early), 'early trials', 'r', -20:20);
            prettyHxg(ax(4), shuffled_del(rews), 'rewarded trials', 'g', -20:20);
            xlabel(ax(4), 'shuffled delta lick time')
        end
        function [p,f, coeffs_DA,true_DA_coeff, allcoeffs, ogcoeffindex,y, mdl, X, yfit, rsq, STATS, ModelPacket] = del_permutation_test(obj, n, Mode, Model, Signal, normalizeX, Early_or_Rew_conditioning, useMask)

            obj.resetLTA(0,500);
            if useMask, obj.useMask();end
            disp('using 0-500ms post-lick for LTA')
            coeffs_DA = nan(n,1);
            othercoeffs = nan(n,1);
            X = cell(n,1);
            Yfit = cell(n,1);
            rsq = nan(n,1);
            STATS = cell(n,1);
            ModelPacket = cell(n,1);
            for iperm = 1:n
                obj.reshuffle_lick_time_next_trial(Early_or_Rew_conditioning);
                [B,~,STATS{iperm}, Yfit, rsq(iperm), ~,ModelPacket{iperm}, ~,y, mdl] = obj.fitModel(Mode, ['shuffled_' Model], Signal, normalizeX, Early_or_Rew_conditioning);
                coeffs_DA(iperm,1) = B(end);
                allcoeffs(iperm, 1:numel(B)) = B;
                % need to get X of each perm
                X{iperm} = mdl.Variables(:, 2:end);
                yfit{iperm} = Yfit;
            end
            [B,~,~, ~, ~, ~,~, ~,~, ~] = obj.fitModel(Mode, Model, Signal, normalizeX, Early_or_Rew_conditioning);
            true_DA_coeff = B(end);
            [coeffs_DA,ogcoeffindex] = sort(coeffs_DA);
            p = sum(coeffs_DA>true_DA_coeff)/n;
            if p>0.5
                p = 1-p;
            end
            [f,ax] = makeStandardFigure();
            prettyHxg(ax, coeffs_DA, 'permuted model DA coefficients', 'k', [], 100);
            yy = get(ax, 'ylim');
            plot(ax, [true_DA_coeff, true_DA_coeff], yy, 'r--', 'linewidth', 3, 'displayname', 'true DA coefficient')
            set(f, 'name', [cell2mat(obj.iv.sessionCode), ' ' Mode, ' ' Model, ' ' Signal, ' nperm=' num2str(n)])
            title(ax, [Early_or_Rew_conditioning ' p = ' num2str(p) ' (min=' num2str(1/n) ')'])

            Str = obj.getUserDataStandards;
            set(gcf, 'userdata', [,...
                'p = obj.del_permutation_test(n=' num2str(n) ', Mode=' Mode ', Model=' Model ', Signal=' Signal ', normalizeX= ' num2str(normalizeX) ', Early_or_Rew_conditioning=' obj.unwrap_Cellstr(Early_or_Rew_conditioning) ')])',...
                '\n\n',...
                Str;
                ])
        end

    end
end